## Copyright Notice

Copyright (C) The Internet Society (2006). 

## 摘要

本文档定义了一个TCP友好型多播拥塞控制（TFMCC）。 `TFMCC` 是一种用于最佳网络环境下的多播传输的拥塞控制机制。 它是一种单速率的拥塞控制方案，发送速率是根据多个接收方中经历最差网络条件下的一方来调整的。 `TFMCC` 在与 `TCP` 流量争夺带宽时具有合理的公平性，而且随着时间的推移，吞吐量的变化相对较小，因此适用于发送速率相对平稳的应用，如流媒体等，它们需要相对平稳的发送速率。

# 1. 介绍

本文规定了TCP友好型多播拥塞控制（TCP-Friendly Multicast Congestion Control，TFMCC）[3]。 `TFMCC` 是一种基于源的、单速率的拥塞控制方案，它建立在单播 `TCP` 友好速率控制机制(`TFRC`)的基础上[4]。 `TFMCC` 在广泛的网络条件下都具有相当的稳定性和响应性，并且可以扩展到几千台数量的接收方组。 为了支持可扩展性，拥塞控制功能被尽可能多的应用到接收方上。 每个接收方不断地确定从发送方到该接收方的路径上的 `TCP` 友好的期望接收速率。 然后，选定的接收方将该速率以反馈数据包的形式报告给发送方。

`TFMCC` 是 RFC 3048[1]中定义的一个构件。 本文档没有指定一个完整的协议，而只是指定了一种拥塞控制机制，它可以在传输协议中使用，如RTP[11]，或在应用层集成了端到端拥塞控制的应用中使用。 本文不讨论数据包格式、可靠性或实现相关问题。

`TFMCC` 的设计是为了在与 `TCP` 流竞争带宽时做到合理公平。 如果一个组播流从发送方到最慢的接收方的发送速率， 是相同拥塞条件下的 `TCP` 流的发送速率的2倍以内，那么这个组播流就是 "合理公平"。

一般来说，`TFMCC` 具有较低的吞吐量变化率，这使得它适用于对发送速率变化要求相对平稳的应用，如流媒体等应用。 在公平竞争带宽的同时，通过处罚机制平滑吞吐量的变化，降低了对可用带宽变化的响应能力。 因此，当应用对平滑吞吐量有要求时，应使用 `TFMCC` ，特别是避免因单个数据包丢失而引起发送速率减半。 而对于那些需要在尽可能短的时间内尽可能多的发送组播数据的应用，PGMCC[10]可能更适合。

根据 `RFC 2357`，在互联网中使用任何可靠的组播协议都需要一个足够有用的拥塞控制方案。 本文档规定了一种实验性的拥塞控制方案。 在等待初步部署和经验表明该方案是有效和可扩展的同时，IETF将该方案公布在 "实验 "类中。

可靠的多播传输(RMT)工作组的意图是，一旦该方案被认为是适用的，就将该规范作为IETF建议标准重新提交。

## 1.1 相关文档

正如RFC 3048[1]中描述的那样，`TFMCC` 是一个构建块，旨在与其他构建块一起使用，以帮助指定协议实例化。 它遵循RFC 3269[2]中提供的一般准则。 特别是，`TFMCC` 是 `NACK-Oriented Reliable Multicast (NORM)` 的一个合适的拥塞控制构建块[5]。

## 1.2 环境要求和注意事项

`TFMCC` 旨在成为一种可以在一个完整的协议实例化中使用的拥塞控制方案，用于交付对象和流（即包括可靠的内容交付，也包括多媒体信息流）。

`TFMCC` 最适用于那些用于传递大量数据（即长度从几百KB到几十KB到几千KB），并且持续时间在几十秒或更多的会话中。

`TFMCC` 是针对多播传输的。 目前，多播传输有两种模式：[6]定义的Any-Source Multicast（ASM）模式和[7]定义的Source-Specific Multicast（SSM）模式。 TFMCC可以与这两种组播模型一起工作，但方式略有不同。 当使用 `ASM` 时，来自接收端的反馈被组播到发送方以及所有其他接收端。 反馈既可以在用于发送数据的同一组地址上进行组播，也可以在单独的组播反馈组地址上进行组播。 对于 `SSM` ，接收方必须将反馈直接单播到发送方。 因此，来自一个接收端的反馈将不会被其他接收端接收到。

`TFMCC` 本质上可以与所有允许双向通信的网络一起工作，包括局域网、广域网、内网、互联网、非对称网络、无线网络和卫星网络。 然而，在某些网络环境中，改变发送速率可能并不一定就能起到好的效果(例如，对于卫星或无线网络，可能没有机制让接收端有效地降低接收速率，因为可能有一个固定的传输速率分配给会话)。

在比特率很低的情况下，`TFMCC` 和 `TCP` 的响应性差异可能会导致吞吐量的显著差异。 `TFMCC` 需要评估丢失事件率来计算公平发送速率。 如果 `TFMCC` 每次 `RTT` 只接收很少的数据包，这个估计可能不准确。 如果瓶颈链路的容量小于30KBit/s（例如，非常慢的调制解调器连接），`TFMCC` 不应该与 `TCP` 一起使用。 在瓶颈链路的缓冲空间严重不足的情况下，`TFMCC` 也可能达到与平均 `TCP` 速率非常不同的速率。 特别是，`TFMCC` 不容易受到较小的缓冲区空间的影响，因为 `TFMCC` 会及时地将数据包发出，而`TCP` 则是背靠背发送。 因此，如果缓冲区空间不足，`TCP` 更容易出现丢包现象。

`TFMCC` 是为那些使用固定的数据包大小的应用而设计的，它的发送速率是以每秒的数据包为单位来响应拥塞情况。 有些应用(例如，使用音频的应用)要求数据包之间有固定的时间间隔，并根据拥塞情况改变其数据包大小，而不是改变其数据包速率。 这些应用不能使用本文中的拥塞控制机制。

# 2. 协议概述

`TFMCC` 将 `TFRC` 的基本机制扩展到组播领域。 为了与 `TCP` 公平竞争，`TFMCC` 接收方单独测量当前网络环境，并计算出一个从发送方到自己的路径上的有利于 `TCP` 的速率。 该速率使用一个 `TCP` 吞吐量方程来确定，该方程大致描述了 `TCP` 的发送速率，是关于丢失事件速率、往返时间（RTT）和数据包大小的函数。 我们将 `丢失事件` 定义为在一个 `RTT` 期间，本应该收到的数据包中有一个或多个被丢失或标记，其中标记的数据包指的是来自于显式拥塞通知(ECN)[9]的拥塞指示。 组播传输的发送速率是根据经历最差网络条件的接收方来调整的。

基本上，`TFMCC` 的拥塞控制机制的工作原理如下。

1. 每个接收方测量丢失事件率及其对发送方的 `RTT` 。

2. 然后每个接收方利用这些信息，使用 `TCP` 吞吐量的方程，得出一个 `TCP` 友好的发送速率。

3. 通过分布式反馈抑制机制，只允许接收方中的一个子集进行反馈，以防止发生反馈风暴。 这种反馈机制可以确保报告较低发送率的接收方，有较高概率可以发送反馈。

4. 反馈未被抑制的接收方将计算出的传输率以所谓的接收方报告的形式反馈给发送方。 接收方报告有两个目的：一是告知发送方适当的传输速率，二是允许接收方测量其 `RTT`。

5. 发送方选择报告速率最低的接收方作为当前限制接收方（`current limiting receiver (CLR)`）。 每当有一个更低的速率反馈到发送方时，相应的接收方就成为CLR，发送速率降低，以匹配该接收方的速率。 当CLR报告的计算速率高于当前发送速率时，发送速率就会增加。

`TFMCC` 的动态性对测量的执行和应用方式，以及选择什么样的反馈抑制机制很敏感。 我们会在下面推荐具体的机制来执行和应用这些测量。 其他机制也是可能的，但必须了解机制之间的相互作用会如何影响 `TFMCC` 的动态转化。

## 2.1 TCP 吞吐量方程

任何可实现的，将TCP吞吐量定义为关于丢失事件速率和RTT的函数方程，都应该适用于 `TFMCC`。 但是，我们注意到，所使用的 `TCP` 吞吐量方程必须能够反映TCP的重传超时行为，因为这在较高的丢包率下的`TCP` 吞吐量中占主导地位。 我们还注意到，吞吐量方程中隐含的关于丢失事件率参数的假设必须与丢包率或丢失事件率的实际测量方式合理匹配。 虽然这种匹配对于下面给出的吞吐量方程和丢失率测量机制来说并不完美，但在实践中，这些假设会变得足够接近。

目前我们推荐的 `TFMCC` 的吞吐量方程是 `Reno TCP` 的吞吐量方程的一个略为简化的版本[8]。

                                   8 s
    X =  ---------------------------------------------------------   (1)
          R * (sqrt(2*p/3) + (12*sqrt(3*p/8) * p * (1+32*p^2)))

这里

  X: 传输速率, 单位为 bits/seconds

  s: 包大小，单位为 bytes

  R: RTT， 单位为 seconds

  p: 丢失事件率，0到1之间，代表丢失事件数占传输的数据包数的几分之一。

可以用不同的 `TCP` 方程来代替这个方程，但要求是吞吐量方程得到的结果，是通过`TCP` 拥塞控制得到的 `TCP` 发送率的合理近似值。

参数 `s` (数据包大小)、 `p` (丢失事件率)和 `R` (RTT)需要由 `TFMCC` 实现来测量或计算。 `R` 的测量在第4.3.2节中规定，`p` 的测量在第5节中规定。 参数 `s` (数据包大小)通常是应用程序知道的。 但在以下两种情况可能会有差异：

1. 数据包的大小会随着数据的不同而变化。 在这种情况下，虽然数据包大小会发生变化，但这种变化并不与传输速率相关联。 通常情况下，使用 `s` 的平均数据包大小的估计值也应该是安全的。

2. 应用程序需要改变数据包大小，而不是改变每秒的数据包数量来执行拥塞控制。 通常情况下，在分组音频应用中，每个数据包需要用固定的时间间隔来表示，就会导致情况。 这类应用需要有不同的参数测量方式。

目前，`TFMCC` 还不能用于第二种情况。

## 2.2 包内容

在指定发送方和接收方功能之前，我们先描述一下发送方发送的数据包和接收方反馈的数据包中包含的拥塞控制信息。 来自发送方的信息既可以在单独的拥塞控制信息中发送，也可以捎带到数据包中。 如果单独的拥塞控制报文的发送时间间隔大于数据包之间的时间间隔(例如，每个反馈周期一次)，那么就需要能够包含用于多个接收方的时间戳信息，以便有足够多的接收方来测量其 `RTT`。

由于 `TFMCC` 将与传输协议一起使用，所以我们不指定数据包格式，因为这取决于所使用的传输协议的细节。 推荐的报头字段的表示方式会在下面给出。 另外，如果浮点表示法的计算开销令人望而却步，可以使用定点算术，但要占用较大的数据包头。 特定 `TFMCC` 实例的发送方和接收方需要就头字段的通用编码达成一致。

### 2.2.1 发送方数据包

数据发送方发送的每个数据包都需要包含以下信息。

1. 序列号i。这个数字每发送一个数据包，就递增一个。 该字段必须足够大，以保证它不会发生环绕，导致两个具有相同序列号的不同数据包，同时出现在接收方最近的数据包历史记录中。 在大多数情况下，序列号将由与 `TFMCC` 一起使用的传输协议提供。

2. 抑制率 `X_supp` ，单位为 `bits/s` 。 只有计算出的速率低于抑制率的接收方才有资格给出反馈，或者它们的 `RTT` 高于下面描述的最大 `RTT`，在这种情况下，它们也有资格给出反馈。 抑制率应表示为 `12` 位浮点值，其中 `5` 位为无符号指数，`7` 位为无符号门特值（表示从100bit/s到400Gbit/s的速率，误差小于1%）。

3. 时间戳 `ts_i` 表示数据包的发送时间。 时间戳的分辨率通常应该是毫秒，时间戳应该是一个无符号的整数值，宽度不小于 `16` 位。

3. 接收方的`ID`，表示为 `r`， 和该接收方最后一次报告的时间戳 `tr_r'=tr_r` 的副本，允许接收方测量其 `RTT`。 如果在接收到来自接收方 `r` 的报告和发送数据包之间有一个延迟 `ts_d` ，那么`tr_r'=tr_r+ts_d` 就会被包含在数据包中。 接收器 `ID` 在下一节中描述。 时间戳回显的分辨率应该是毫秒，时间戳应该是一个不小于 `16` 位宽的无符号整数值。 如果使用单独的拥塞控制报文而不是捎带式的报文，则数据包需要包含一个具有相应时间戳的接收方 `ID` 列表，以允许足够多的接收方同时测量其 `RTT`，默认对应于10到20个条目的列表大小。

4. 标志 `is_CLR` ，表示 `ID` 为 `r` 的接收方是否为 `CLR`。 

5. 一个反馈回合（`feedback round`）计数器 `fb_nr` ，这个计数器在新的反馈回合开始时由发送方递增，以通知接收方所有的反馈回合应该被抑制。 反馈回合计数器至少要有 `4` 位宽。

6. 最大 `RTT` 值 `R_max` ，代表所有接收方的 `RTT` 的最大值。 `RTT` 值应以毫秒为单位进行测量。 应使用一个 `8` 位浮点值，其中 `4` 位为无符号指数，`4` 位为无符号门特值（表示1毫秒到64秒的RTT，误差约为6%）。

### 2.2.2 反馈包

数据接收方发送的每个反馈数据包都包含以下信息。

1. 在大多数情况下，接收方 `ID` 是由传输协议提供的，但它可能只是接收方的 `IP` 地址。

2. 一个标志 `have_RTT` ，表示接收方是否在加入会话后至少进行了一次 `RTT` 测量。

3. 一个标志 `have_loss` 表示接收方自加入会话以来是否经历了至少一次丢包事件。

4. 一个标志 `receiver_leave` 表示接收方将离开会话（因此不应该是 `CLR`）。

5. 时间戳 `tr_r`，表示反馈数据包何时发送。 时间戳的表示方式应该与数据包中的时间戳回显的表示方式相同。

6. 回显 `ts_i'` 表示最后一个数据包接收到的时间戳。 如果接收方接收到的最后一个数据包的序列号为 `i` ，那么 `ts_i'= ts_i` 就包含在反馈中。 如果在接收到该最后一个数据包和发送反馈之间有一个延迟 `tr_d` ，那么 `ts_i'= ts_i+tr_d` 被包含在反馈中。 时间戳回显的表示方式应该与数据包中的时间戳相同。

7. 反馈回合回显 `fb_nr` ，反映到目前为止收到的最高反馈回合计数器值。 反馈回合回显的表示方式应与数据包中的反馈回合计数器的表示方式相同。

8. 所需的发送速率 `X_r` 。 这是接收方计算出的，从发送方到这个接收方的路径上的 `TCP` 友好的速率。 所需发送率的表示方式应与数据包中的抑制率相同。

# 3. 数据发送协议

数据发送方以控制的速率向数据接收方组播数据包流。 每当收到反馈，发送方就会检查是否需要切换 `CLR` 并重新调整发送速率。

TFMCC发送方必须提供的主要功能有：

1. 调整发送速率。

2. 控制接收方的反馈，以及

3. 协助接收端进行 `RTT` 测量。

## 3.1 发送方初始化

在发送方初始化时，将最大 `RTT` 设置为一个指定值，该值应大于任何一个接收方的最大 `RTT` 。 它不应小于 `500` 毫秒，以便在公共互联网上运行。 发送速率 `X` 被初始化为：在每段最大 `RTT` 时间内发送一个数据包。

## 3.2 计算最大 `RTT`

对于每一个到达发送方的反馈数据包，计算出当前链路的瞬时 `RTT` 为

    R_r = ts_now - ts_i'

其中 `ts_now` 是反馈数据包到达的时间。 接收方将调整 `ts_i'` ，以包含接收到最后一个数据包时间戳和发送相应的报告之间的时间间隔（见上面反馈包中 `ts_i'` 字段），因此这个时间间隔将不包括在 `R_r` 中。 如果实际的 `RTT` 小于时间戳的分辨率，并且 `ts_now` 等于 `ts_i'` ，那么 `R_r` 被设置为大于 `0` 的最小正向 `RTT` 值(即在我们的情况下为1毫秒)。 如果瞬时 `RTT` 大于当前最大 `RTT` ，则最大 `RTT` 增加到该值。

    R_max = R_r

否则，如果在反馈回合中没有收到高于最大 `RTT` 的瞬时 `RTT` 的反馈（见第3.4节），则最大 `RTT` 降低为

    R_max = MAX(R_max * 0.9, R_peak)

其中 `R_peak` 为反馈回合中测得的接收方 `RTT` 峰值。

最大 `RTT` 主要用于异构 `RTT` 接收方之间的反馈抑制。 反馈抑制与数据包的发送密切相关，为此，最大 `RTT` 不能低于连续数据包之间的最大时间间隔。

    R_max = max(R_max，8s/X + ts_gran)

其中 `ts_gran` 是发送方系统时钟的粒度（见3.7节）。

## 3.3 调整发送率

当接收方 `r` 的反馈数据包到达发送方时，发送方要检查是否需要调整传输速率，并切换到新的 `CLR` 。

如何调整速率取决于接收方报告的期望速率 `X_r` 。 我们将其分为四种情况。

1.  如果没有 `CLR` ，接收方 `r` 成为当前的限制接收方。 发送速率 `X` 直接设置为 `X_r` ，只要速率增加小于 `(8s/R_max bits)/s` （即每 `R_max` 一个数据包）。 否则 `X` 以每 `R_max` 不超过 `(8s/R_max bits)/s` 的增加速率逐渐增加，直到 `X_r`。

2.  如果接收方 `r` 不是 `CLR` ，但有 `CLR` 存在，那么如果 `X_r` 小于当前发送速率 `X` ，且该接收方报告中的 `receiver_leave` 标志未设置，则接收方 `r` 成为当前限制接收方。 此外，发送速率降低为 `X_r`。

3.  如果接收方 `r` 不是 `CLR` ，但有一个 `CLR` 存在，且该 `CLR` 的上次报告的 `receiver_leave` 标志被设置，则接收方 `r` 成为当前的限制接收方。 但是，如果 `X_r>X` ，则在反馈回合的持续时间内，发送速率不会增加到 `X_r`，以允许其他（速率较低的）接收方进行反馈并被选为 `CLR`。

4.  如果接收方 `r` 为 `CLR` ，则发送速率被设置为 `X_r` 和 `X+8s/R_max bits/s` 的最小值。

如果接收方还没有测出其 `RTT` ，但已经经历了数据包丢失（由接收方报告中的相应标志表示），则接收方报告将包括一个期望的速率，该速率是基于最大 `RTT` ，而不是实际的 `RTT` 给该接收方。 在这种情况下，发送方使用其测量到该接收器的瞬时 `RTT R_r` 来调整期望速率。

    X_r' = X_r * R_max / R_r

然后用 `X_r'` 代替 `X_r` 来检测是否切换到新的 `CLR`。

如果 `TFMCC` 发送方在4个 `RTTs` 内没有收到来自 `CLR` 的报告，除非从选择 `CLR` 到现在经历少于10个 `RTTs`，否则发送速率将减半。 此外，如果发送方在至少10个 `RTT` 内没有收到来自 `CLR` 的报告，则假定 `CLR` 崩溃或离开组。 从随后到达发送方的反馈中选择一个新的 `CLR` ，我们按照上面案例3中的方法增加。

如果不能选择新的 `CLR` (即在没有任何一个接收方的反馈的情况下)，则需要进一步降低发送率。 在没有反馈的情况下，每连续10次 `RTT` ，发送率就会减少一半。 这个速率最多减少到每 `8` 秒一个数据包。

注意，当接收方停止接收数据包时，会停止发送反馈。 这最终会导致在网络故障的情况下，发送速率降低。 如果网络随后恢复，则每隔R_max间隔时间，`CLR` 的计算速率将以 `8s/R_max bits/s` 进行线性增加（按上面第4条的计算进行）。

使用 `TFMCC` 的应用程序可能有一个最低发送速率要求，如果发送速率连续低于这个最低速率，应用程序就会变得不可用。 应用程序应该将报告这种低速率的接收方排除在多播组之外。 这样做的具体机制取决于应用程序，不在本文的范围之内。

## 3.4 控制接收方反馈

允许发送反馈报告的接收方，在所谓的反馈回合中确定。 反馈回合的持续时间 `T` 为最大 `RTT` 的 `6` 倍。 如果多播模型为 `ASM`（即接收方反馈是向整个组内多播），则反馈回合的持续时间可以减少到最大 `RTT` 的 `4` 倍。

只有希望报出低于抑制率 `X_supp` 的接收方，或者 `RTT` 高于 `R_max` 的接收方才可以发送反馈。 在每一轮反馈开始时，`X_supp` 被设置为可以表示的最高值。 当反馈在一个反馈回合的过程中到达发送方时，`X_supp` 会减少，这样在回合结束时，越来越多的反馈会被抑制。 接收方反馈是如何在反馈回合中分布的，将在4.5节中讨论。

每当当前回合的非 `CLR` 反馈到达发送方时，`X_supp` 就会减少为

   X_supp = (1-g) * X_r

如果 `X_supp>X_r` ，不仅是导致相应的接收方被选择为 `CLR` 的反馈，而且来自非 `CLR` 接收方的反馈，也会导致反馈抑制。 请注意，在使用最大 `RTT` 计算 `X_r` 的情况下，发送方不允许调整 `X_r` ，以反映接收方的实际 `RTT` ，就像设置发送速率一样(3.3节)；否则，反馈风暴还是有可能会发生。 参数 `g` 决定了较高的速率反馈可以在多大程度上抑制较低的速率反馈。 这种机制保证了所报告的最低计算速率在接收方集合的实际最低计算速率的 `g` 的一个系数内（见[13]）。 建议g的值为0.1。

为了让接收方抑制其反馈，每当收到反馈时，需要更新发送方的抑制率。 这个抑制率必须及时地传达给接收者，可以将其包含在数据包头中，或者，如果使用单独的拥塞控制报文，则每当抑制率发生显著变化时(即，当抑制率降低到小于 `(1-g)` 倍于先前公布的抑制率时，就发送一条带有抑制率的报文。)

在时间跨度为 `t` 后，如果在这段时间内收到非 `CLR` 反馈，则反馈回合结束。 否则，当第一个非 `CLR` 反馈信息到达发送方时，反馈回合结束，但最多在 `2T` 之后，反馈回合结束。 反馈回合计数器递增1，并将抑制率 `X_supp` 重置为可代表的最高值。 反馈回合计数器在绕行后以 `0` 回合重新启动。

## 3.5 辅助接收方侧RTT测量

接收方通过发送一个时间戳，并结合接收方报告来测量其 `RTT`，而时间戳会由发送方回传。 如果拥塞控制信息被捎带到数据包上，通常只能包含一个接收方 `ID` 和时间戳。 如果在两个数据包之间的时间间隔内有多个来自不同接收方的反馈信息到达发送方，发送方必须决定让哪个接收方测量 `RTT` 。 如果单独的拥塞控制报文允许同时回传多个接收方时间戳，但如果自上次拥塞控制报文后，反馈的接收方数量超过了列表大小，也同样需要决定向谁进行响应。

发送方的时间戳回显按以下优先级顺序进行处理:

1. 一个新的 `CLR`（换了CLR后）或一个以前没有进行过任何 `RTT` 测量的 `CLR`

2. 之前没有进行过 `RTT` 测量的接收方，按接收方报告的反馈回合回显（`fb_nr`）的顺序进行处理(即旧的反馈会先被处理)。

3. 使用前次 `RTT` 测量值的非 `CLR` 接收方，再次按反馈回合回显（`fb_nr`）报告的升序排列

4. `CLR`

通过使用以上关系以有利于具有最低报告速率的接收器。

有必要考虑到从接收报告到发送下一个数据包之间的时间。 这个时间需要从 `RTT` 中扣除，因此必须体现在接收器的时间戳值中。

每当两个数据包之间的时间间隔内没有反馈数据包到达时，`CLR` 的最后一个时间戳值，通过适当的偏移量调整后，就会被回传。 当每个 `RTT` 的数据包数量太少，以至于所有的数据包都带有非 `CLR` 接收方的时间戳时，`CLR` 的时间戳和 `ID` 至少在每个反馈回合中都需要被包含在数据包中一次。

## 3.6 慢启动

`TFMCC` 使用慢启动机制，在会话开始时快速接近其合理的带宽份额。 在慢启动期间，发送速率会呈指数级增长。 速率的增长被限制在接收方报告中包含的最小速率，而接收方报告的速率则是它当前接收速率的两倍。 与正常的拥塞控制模式一样，报告速率最小的接收方成为 `CLR` 。 由于接收方永远不能以高于其链路带宽的速率接收数据，这有效地将速率限制在这个带宽的两倍以内。 如果每 `R_max` 的增长速度小于 `(8s/R_max bits)/s` ，发送方可以选择每隔 `R_max` 增加 `(8s/R_max bits)/s` 。 在一个个 `RTT` 过程中，当前发送速率逐渐调整到接收方报告中报告的目标速率。 当任何一个接收方出现第一次丢包时，慢启动就会终止。 由于该接收方的计算速率将低于当前发送速率，因此该接收方将被选择为 `CLR` 。

在慢速启动期间，每次 `RTT` 增加 `(8s/R_max bits)/s` 的速率上限不适用。 只有在 `TFMCC` 发送方收到第一份设置了 `have_loss` 标志的报告后，才会以这种方式限制速率增加。

慢启动也可以在发送方空闲一段时间后使用，以快速达到之前的发送速率。 当发送方停止发送数据包时，会记录当前发送速率 `X'=X`，每隔 `10` 个RTT，由于缺乏接收方反馈，允许的发送速率就会减半，如3.3节规定的那样。 这种减半可能会发生多次。 当发送方恢复后，可能会从当前允许的发送速率到记录的速率 `X'` 执行慢速启动。 慢速启动在任何一个接收方的第一个数据包丢失后，或达到 `X'` 后立即结束。

为此，接收方必须在没有数据包的 `10` 个RTT后，按照第4.3.1节中的规定清除 `have_loss` 标志。 `have_loss` 标志只在慢速启动期间使用。 因此，如果由于网络断开或数据包丢失导致没有数据包到达，清除该标志没有任何效果。

## 3.7 数据包传输调度

由于 `TFMCC` 是基于速率的，并且由于操作系统通常无法精确地调度事件，因此有必要在发送数据包时保持机会，以便在操作系统的粒度或调度不规则的情况下也可以保持正确的平均速率。 因此，一个典型的发送循环将计算出正确的数据包间间隔，即 `ts_ipi` ，如下所示。

    ts_ipi = 8s/X

当发送方第一次在时间点 `t_0` 开始发送时，通过计算 `ts_ipi` ，从而计算出数据包 `1` 的额定发送时间：`t_1 = t_0 + ts_ipi`。 当应用程序变得空闲时，它将检查当前时间 `ts_now`，然后在 `(ts_ipi-(ts_now-t_0))` 秒后请求重新调度。 当应用程序被新调度时，它再次检查当前时间 `ts_now` 。 如果 `(ts_now > t_1 - delta)`，则发送数据包 `1` (参见下面的 `delta`)。

现在，可以计算出一个新的 `ts_ipi`，用于计算数据包 `2` 的额定发送时间 `t_2：t_2 = t_1 + ts_ipi` 。 然后重复这个过程，每个连续的数据包的发送时间都是由前一个数据包的额定发送时间计算出来的。 注意，数据包包头中的时间戳，包含的是实际发送时间 `ts_i` ，而不是额定发送时间。

在某些情况下，当计算出下一个数据包的额定发送时间 `t_i` 时，可能已经出现了 `ts_now>t_i - delta` 的情况。 在这种情况下，应该立即发送数据包。 因此，如果操作系统的定时器粒度较粗，且传输速率较高，那么 `TFMCC` 可能会发送由多个数据包组成的短的突发包，间隔为操作系统定时器粒度的间隔。

参数 `delta` 是为了让一个数据包的发送时间有一定的灵活性。 如果操作系统的调度定时器粒度为 `ts_gran` 秒，那么 `delta` 通常会被设置为。

    delta = min(ts_ipi/2, ts_gran/2)

`ts_gran` 在许多 `Unix` 系统中是 `10` 毫秒。 如果不知道 `ts_gran` ，可以安全地假设为 `10` 毫秒。

# 4 数据接收协议

接收方测量当前的网络状况（即 `RTT` 和丢失事件速率），并利用这些信息计算出对在竞争流量时相对公平的速率。 然后将该速率以接收方报告的形式传递给发送方。由于接收方的数量可能很多，所有肯定不希望所有的接收方都发送报告，特别是同时发送报告。

在对接收方功能的描述中，我们将首先讨论接收方如何测量网络参数，然后讨论反馈过程。

## 4.1 接收方初始化

接收器在接收到第一个数据包时被初始化。 `RTT` 被设置为数据包中包含的最大 `RTT` 值。 这个初始值作为接收方的 `RTT`，直到第一次真正的 `RTT` 被测量出来为止。 丢失事件速率被初始化为0，同时，标志 `receiver_leave` 、 `have_RTT` 和 `have_loss` 被清除。

## 4.2 接收方退出

如果接收方发送了反馈，但希望在下一轮反馈中离开 `TFMCC` 会话，可以在报告中设置 `receiver_leave` 标志，以表示准备离开。 如果离开的接收方是 `CLR`，在离开生效之前，应该在反馈回合内的所有报告中设置 `receiver_leave` 标志。

## 4.3 网络拥塞的测量

接收方在接收到每一个新的数据包后，必须更新他们对网络参数的估计。

### 4.3.1 更新丢失事件率

当接收到一个数据包时，接收方将该数据包添加到数据包历史记录中。 丢失事件率的测量机制在第5节中单独描述。

当检测到丢失事件时，标志 `Have_loss` 被设置。 如果连续10个 `RTT` 没有收到数据包，则清除该标志，允许发送方慢速启动。 当有新的数据包到达并检测到丢失事件时，它将被再次设置。

### 4.3.2 基础RTT测量

当接收方收到一个 `r` 字段与自己 `ID` 相同的数据包时，就会更新 `RTT` 估计值。

1.  当前RTT的计算公式为

    R_sample = tr_now - tr_r'

    其中 `tr_now` 是数据包到达接收方的时间，`tr_now` 是数据包中回传的接收方报告时间戳。 如果实际 `RTT` 小于时间戳的分辨率，且 `tr_now` 等于 `tr_r'` ，则 `R_sample` 被设置为大于0的最小正向 `RTT` 值(即在我们的情况下为1毫秒)。

2.  平滑后的 `RTT` 估计值 `R` 被更新。

    如果之前没有收到反馈，则

        R = R_sample

    其他

        R=q*R+(1-q)*R_sample

    建议非 `CLR` 接收方的滤波器参数 `q` 为 `0.5` 。 `CLR` 执行 `RTT` 测量的频率更高，因此应该使用更高的滤波值。 我们建议使用 `q=0.9`。 注意，`TFMCC` 对滤波器常数的精确值不敏感。

可以选择使用基于发送方的 `RTT` 测量，而不是基于接收方的 `RTT` 测量。 发送方已经根据接收方自己的时间戳回显来确定对接收方的 `RTT` ，以计算最大 `RTT`。 对于基于发送方的 `RTT` 测量，这个 `RTT` 测值需要传递给接收方。 发送方不再发送接收方时间戳的回显 `tr_r'`，而是在下一个数据包中包含接收方的 `RTT`，使用3.5节中描述的优先级规则。

为了简化发送方的操作，仍应在接收方对 `RTT` 采样的进行上述平滑处理。

### 4.3.3 单向延迟调整

当进行 `RTT` 测量时，接收方还确定了从自身到发送方的单程延迟 `D_r` 。

    D_r = |tr_r' - ts_i|

    注：原文中这里没有取绝对值，但如果不取绝对值会影响到公式的理解，所以这里加上。我对不加绝对值的公式进行演算，发现怎么算都不对，浪费了大量时间。

其中 `ts_i` 和 `tr_r'` 是数据包中包含的时间戳和接收方报告时间戳回显。 对于每个接收到的新的数据包 `j` ，接收器可以计算出一个更新的 `RTT` 估计值。

    R' = max(D_r + tr_now - ts_j, 1毫秒)

在 `RTT` 测量之间，使用更新的 `R'` 代替平滑的 `RTT R` 。与 `RTT` 样本一样，`R'` 必须严格为正。当进行新的测量时，所有的中间单向延时测量都被丢弃（即，根据第4.3.2节更新平滑化的 `RTT` ，不考虑中间单向延时调整）。

对于单向延时测量，发送方和接收方的时钟不需要同步。 只要实际 `RTT` 测量之间的时钟漂移可以忽略不计，当两个单向测量值相加形成 `RTT` 估计值时，两端的时钟偏斜将自行抵消。

当使用基于发送方的 `RTT` 测量时，应该对发送方提供的 `RTT` 进行同样的单向延迟调整。

### 4.3.4 接收速率测量

当接收器没有经历过任何丢包事件时，它不能计算出一个TCP友好的速率来包含在接收器报告中。 相反，如果出现丢包事件，则接收器可以测量出当前的接收速率，并将期望速率 `X_r` 设置为接收速率的两倍。

接收速率以 `bits/s` 为单位，测量的是过去 `k` 个 `RTT` 中接收到的比特数，考虑到IP和运输层数据包头，但不包括链路层数据包头。 建议 `k` 的值在2到4之间。

## 4.4. 设置期望的速率

当接收方测量到一个非零丢失事件率时，它会使用方程(1)计算出期望的速率。 如果还没有测量 `RTT`，则用最大 `RTT` 代替接收方的 `RTT` 。 每当丢失事件率或 `RTT` 发生变化时，预期速率 `X_r` 就会被更新。

接收方可能决定不报告低于每8秒1个数据包的期望速率，因为发送方从这种低发送速率中恢复的速度非常慢。 在这种情况下，接收器报告的期望速率为每8秒1个数据包。 但是，如果在超过120秒的时间里，计算出的速率低于报告的速率，并且当前发送速率高于接收方计算出的速率，它必须离开组播组。

如上所述，在接收方经历第一次丢失事件之前，无法计算出所需的速率。 在这种情况下，将接收方报告中的数据接收速率的两倍作为 `X_r` 包含在接收方报告中，以允许发送方按照第3.6节中描述的那样慢速启动。 这也是在由于发送方空闲而导致接收方清除了 `have_loss` 标志后，发送方恢复发送数据包时的情况。

## 4.5 反馈与反馈抑制

将 `fb_nr` 做为接收方接收到的最高反馈回合计数值。 当一个新的数据包到达时，反馈回合计数值高于 `fb_nr` 时，一个新的反馈回合开始，并更新 `fb_nr` 。 旧回合的未完成的反馈被取消。 如果收到的反馈号的值比 `fb_nr` 低一半以上的反馈号空间，则接收方就可以假定反馈回合计数器出现了环绕，同时取消反馈定时器并更新 `fb_nr`。

`CLR` 在每个 `RTT` 中独立于所有其他接收方发送一次反馈。 它的反馈不抑制其他反馈，也不能被其他接收方的反馈所抑制。

非 `CLR` 接收方在一个反馈回合开始时设置一个反馈定时器。 使用指数加权随机定时器机制，反馈定时器被设置成在

    t = max(T* (1+log(x)/log(N)), 0)

其中

   x是均匀分布在(0，1]中的随机变量。

   T为反馈回合的持续时间（即6*R_max）。

   N是对接收方数量的估计上限。

`N` 是 `TFMCC` 协议所特有的一个常数。 由于 `TFMCC` 最多可以扩展到数千个接收方，因此建议将 `N` 设置为 `10,000` 个接收方（并将 `TFMCC` 会话限制为最多 `10,000` 个接收方）。

当反馈定时器超时时，如果没有提前取消定时器, 则会发送一个反馈数据包。当组播模式为 `ASM` 时，反馈是组播到整个组；否则，反馈是单播到发送方。 反馈数据包包括反馈数据包发送时的有效速率（而不是反馈定时器设置时的速率）。 在反馈数据包中包含的最后一个接收到的数据包的时间戳 `ts_i` 的副本，需要根据接收到数据包和发送报告之间的时间间隔进行调整，以使发送方能够正确推断出瞬时 `RTT`（即该时间间隔必须加上时间戳值）。

如果接收到一个数据包，其抑制率低于接收方的计算速率，且最大 `RTT` 高于或等于接收方的 `RTT`，则定时器被取消。 同样的，一个指示新反馈回合开始的数据包也会取消所有旧的反馈回合。 在 `ASM` 的情况下，如果收到来自另一个非 `CLR` 接收方的反馈数据包，报告的速率较低时，定时器也会被取消。

反馈抑制的过程比较复杂，因为在一个反馈回合中，接收方的计算速率会发生变化。 如果所有接收方的计算速率迅速下降，反馈抑制就不能再防止反馈风暴，因为早期的反馈总是会报告比当前反馈高的速率。 为了使反馈抑制机制在面对不断变化的速率时稳健，有必要引入 `X_fbr` ，即一个接收方在反馈回合开始时的计算速率。 接收方不仅需要在抑制率小于接收方的当前计算速率时抑制其反馈，而且在抑制率低于 `X_fbr` 的情况下也需要抑制其反馈。

当一个反馈回合中最大 `RTT` 发生重大变化时，需要根据变化的比例重新安排反馈定时器。

    t=t*R_max/R_max'

其中 `R_max` 是新的最大RTT，`R_max'` 是之前的最大 `RTT` 。 当最后一个数据包的接收时间间隔超过 `R_max` 时，也同样需要进行处理。 在这种情况下，需要将数据包间的间隙和最大 `RTT` 的差值加到反馈时间中，以防止反馈风暴（例如，在发送方崩溃的情况下）。

    t = t + max(tr_now - tr_i - R_max, 0)

其中 `tr_i` 是最后一个数据包到达接收方的时间。

关于反馈抑制机制的特点，更多的细节可以在[13]和[3]中找到。

# 5. 计算丢失事件率

准确、稳定的丢失事件率测量对于 `TFMCC` 来说是最重要的。 丢失事件率的测量是在接收方上进行的，根据到达的数据包的序列号，来检测丢失或标记的数据包。

## 5.1 检测丢失或标记的数据包

`TFMCC` 假设所有的数据包都包含一个序列号，每个发送的数据包都有一个递增的序列号。 为了本规范的目的，我们要求，如果丢失的数据包被重传，那么重传的数据包将被赋予一个新的序列号，这个新的序列号是传输序列中最新的序列号，而不是与丢失的数据包相同的序列号。 如果一个传输协议有要求必须以原始序列号重传，那么传输协议设计者必须想办法区分延迟的数据包和重传的数据包，以及如何检测丢失的重传。

每个接收方都维护着一个数据结构，用来跟踪哪些数据包已经到达，哪些丢失了。 为了规范的目的，我们假设数据结构由一个已经到达的数据包列表和每个数据包的时间戳组成。 在实际应用中，这种数据结构通常会以更紧凑的形式存储，但这是特定于实现的。

一个数据包的丢失是通过至少有三个序列号比丢失的数据包高的数据包到达来检测。 对后续三个数据包的要求与TCP相同，是为了使 `TFMCC` 在出现重排序时更稳健。 与TCP不同的是，如果一个数据包晚到了（在3个后续数据包到达后），那么晚到的数据包可以填补接收记录中的空洞，接收方可以重新计算丢失事件率。

对于支持 `ECN` 的连接，一个被标记的数据包一到达就被检测为拥塞事件，无需等待后续数据包的到来。

## 5.2 从丢失历史记录到丢失事件的转换

`TFMCC` 要求丢失事件率在存在连续多个丢包的情况下，如果这些数据包是同一个丢包事件的一部分，那么丢包事件率就必须保持不变。 这与TCP类似，在任何一次 `RTT` 期间，TCP（通常）只执行拥塞窗口的一半。 因此，接收方需要将数据包丢失历史记录映射到丢失事件记录中，其中丢失事件是指一个或多个 `RTT` 中丢失的数据包。

为了确定一个丢失或标记的数据包应该启动一个新的丢失事件，还是作为现有丢失事件的一部分来计算，我们需要比较到达接收方的数据包的序列号和时间戳。 对于一个被标记的数据包 `S_new`，可以直接记下它的接收时间 `T_new`。 对于丢失的数据包，我们可以通过插值来推断出标称的 "到达时间"。 假设。

`S_loss` 是丢失数据包的序列号。

`S_before` 是最后一个在 `S_loss` 之前到达的数据包的序列号。

`S_after` 是第一个在 `S_loss` 后到达的数据包的序列号。

`T_before` 是 `S_before` 的接收时间。

`T_after` 是 `S_after` 的接收时间。

注意，由于重新排序，`T_before` 可以在 `T_after` 之前，也可以在 `T_after` 之后。

对于一个丢失的数据包 `S_loss` ，我们可以从 `S_before` 和 `S_after` 的到达时间中插值出它在接收方的理论 "到达时间"。 因此

   T_loss = T_before + ( (T_after - T_before)
               * (S_loss - S_before)/(S_after - S_before))。

注意，如果序列空间在 `S_before` 和 `S_after` 之间出现环绕，那么在计算前必须修改序列号，以覆盖这种情况。 如果可能的最大序列号是 `S_max`，并且 `S_before` > `S_after`，那么通常情况下，修改每个序列号 `S`：

    S'=(S+(S_max+1)/2)mod(S_max+1)

就足够了。

如果确定丢失的数据包 `S_old` 已经开始了前一个丢失事件，而我们刚刚确定 `S_new` 已经丢失，那么我们将 `S_old` 和 `S_new` 的理论到达时间进行内插，分别称为 `T_old` 和 `T_new` 。

如果 `T_old+R>=T_new` ，那么 `S_new` 就是现有的丢失事件的一部分。 否则，`S_new`是新的丢失事件的第一个数据包。

## 5.3 丢失事件区间

如果确定一个丢包区间 `A` 以数据包序列号 `S_A` 开始，而下一个丢包区间 `B` 以数据包序列号 `S_B` 开始，则丢包区间 `A` 中的数据包数量由 `(S_B-S_A)` 给出。

## 5.4 平均丢包区间

为了计算丢失事件率 `p` ，我们首先计算平均丢失区间。 这里用一个滤波器来完成的，该滤波器对 `n` 个最近的丢失事件区间进行加权，使测得的丢失事件率平稳变化。

权重 `w_0` 到 `w_(n-1)` 的计算方法为。

    IF(i < n/2)
        w_i = 1;
    Else
        w_i = 1 - (i - (i - (n/2 - 1)))/(n/2 + 1);

因此，如果n=8，则w_0到w_7的值分别为。

     1.0, 1.0, 1.0, 1.0, 0.8, 0.6, 0.4, 0.2

在计算丢失事件率时，丢失事件率所使用的丢失区间数的值 `n` 决定了 `TFMCC` 对拥塞程度变化的响应速度。 按照目前的规定，对于可能在全局互联网中与TCP竞争的流量，`TFMCC` 的值 `n` 明显大于8时，不应该使用 `TFMCC`。 如果想在 `n` 值大于8的情况下安全运行，需要对 `TFMCC` 的机制稍作改变，使其能对两次或更多的往返时间的严重丢包现象做出更严厉的响应。

在计算平均丢包区间时，我们需要决定是否包含最近一次丢包事件以来的区间。 只有当它足够大，足以增加平均丢包区间时，我们才会这样做。

因此，如果最近的丢包区间为 `I_0` 到 `I_n` ，其中 `I_0` 是最近一次丢包事件以来的区间，那么我们计算平均丢包区间 `I_mean` 为

    I_tot0 = 0;
    I_tot1 = 0; 
    W_tot=0;
    for (i = 0 to n-1) {
      I_tot0 = I_tot0 + (I_i * w_i);
      W_tot = W_tot+w_i;
    }
    for (i = 1 to n) {
      I_tot1 = I_tot1 + (I_i * w_(i-1)));
    }
    I_tot = max(I_tot0, I_tot1);
    I_mean = I_tot/W_tot;

丢失事件率，p简单来说就是。

  p = 1 / I_mean。

## 5.5 历史折损（History Discounting）

如5.4节所述，在计算平均丢失区间时，无论最近丢失区间的大小，最近的丢失区间只占总权重的4/(3*n)。 本节将介绍一种可选的历史折损机制，当最近的丢失区间大于计算的平均丢失区间的两倍以上时，`TFMCC` 接收方可以调整权重，将更多的相对权重集中在最近的丢失区间上。

为了进行历史折损，我们将折损因子 `DF_i` 与每个丢失区间 `L_i` 关联，其中每个折损因子是一个浮点数。 折损数组维护了每个丢失区间的累计历史折损值。 开始时，折损数组中的 `DF_i` 的值被初始化为1。

    for (i = 0 to n) {
      DF_i = 1;
    }

历史折损也使用折损系数 `DF` ，是一个浮点数，也是初始化为1。 首先，我们展示了折现系数是如何用于计算平均丢失区间的，然后在本节的后面，我们将描述折现系数是如何随着时间的推移而修改的。

如第5.4节所述，平均丢失区间的计算是使用n个以前的丢失区间I_1，...，...，I_n，以及代表上次丢失事件后收到的数据包数量的区间I_0来计算平均丢失区间。 使用折现系数计算平均丢失区间是对5.4节中的过程进行简单的修改，计算方法如下。

    I_tot0 = I_0 * w_0
    I_tot1 = 0;
    W_tot0 = w_0
    W_tot1 = 0;
    for (i = 1 to n-1) {
      I_tot0 = I_tot0 + (I_i * w_i * DF_i * DF_i * DF);
      W_tot0 = W_tot0 + w_i * DF_i * DF_i * DF;
    }
    for (i = 1 to n) {
      I_tot1 = I_tot1 + (I_i * w_(i-1) * DF_i);
      W_tot1 = W_tot1 + w_(i-1) * DF_i;
    }
    p = min(W_tot0/I_tot0，W_tot1/I_tot1);

折损系数 `DF` 在每一个数据包到达时更新，具体方法如下。 首先，接收方计算丢失区间I_1，...，I_n的加权平均值I_mean。

    I_tot = 0;
    W_tot = 0;
    for (i = 1 to n) {
      W_tot = w_(i-1) * DF_i;
      I_tot = I_tot + (I_i * w_(i-1) * DF_i);
    }
    I_mean = I_tot/W_tot;

这个加权平均数 `I_mean` 与上次丢失事件后收到的数据包数量 `I_0` 进行比较。 如果 `I_0` 大于 `I_mean` 的两倍，则新的丢失区间比旧的丢失区间大得多，折损系数 `DF` 会被更新，以降低旧区间的相对权重，如下所示。

    if (I_0 > 2 * I_mean) {
      DF = 2 * I_mean/I_0;
      if (DF < THRESHOLD)
        df = threshold;
    } or 
      DF = 1。

`THRESHOLD` 的非零值可以确保在较早的高拥堵时间内的较早的丢失区间不会被完全抵消。 我们建议`THRESHOLD` 为0.5。 注意，每当有新的数据包到达时，`I_0` 会进一步增加，折损系数 `DF` 会被更新。

当有新的丢失事件发生时，当前区间 `I_0` 转移到 `I_1` ，丢失区间 `I_i` 转移到区间 `I_(i+1)` ，丢失区间 `I_n` 被遗忘。 前面的折现系数 `DF` 必须纳入折现数组中。 由于 `DF_i` 携带了与丢失区间 `I_i` 相关的折现因子，因此DF_i数组也必须进行移位。 具体方法如下。

  for (i = 1 to n) {
    DF_i = DF * DF_i;
  }
  fro (i = n-1 to 0 步-1) {
    DF_(i+1) = DF_i。
  }
  I_0 = 1;
  DF_0 = 1。
  DF = 1。

这就完成了对可选的历史折损机制的描述。 我们强调，这是一个可选的机制，其唯一的目的是让 `TFMCC` 能够更快速地响应突然出现的拥塞，具体表现为较长的丢失区间。

## 5.6 第一次丢失事件后初始化丢失记录

在第一次丢失事件发生前收到的数据包数量通常不能反映当前丢失事件速率。 当第一次丢失事件发生时， `TFMCC` 接收器假设正确的数据速率是丢失事件发生时最后一次 `RTT` 期间接收数据的速率。 `TFMCC` 接收方不将第一个丢失区间初始化为直到第一个丢失事件发生前发送的数据包数，而是计算出产生接收速率 `X_recv` 所需的丢失区间，并使用这个合成的丢失区间 `l_0` 作为丢失历史机制的种子。

初始丢失区间是通过反推一个简化版的TCP方程(1)来计算的。

                                8s
    X_recv = sqrt(3/2) * -----------------
                          R * sqrt(1/l_0)

                  X_recv * R
    ==> l_0 = (----------------)^2
                sqrt(3/2) * 8s


与使用更精确的等式(1)相比，在较高的丢失率下，产生的初始丢失区间太小，导致初始丢失事件率更保守。

如果接收方仍然使用初始 `RTT R_max` 而不是其实际 `RTT`，那么在初始 `RTT` 高于实际 `RTT` 的情况下，初始丢失区间过大。 其结果是，当第一次 `RTT` 测量 `R` 时，接收方将计算出过高的期望速率，如果初始丢失区间仍在丢失历史中。 接收方必须按以下方法调整 `l_0`。

    l_0 = l_0 * (R/R_max)^2

如果第一次 `RTT` 测量发生是在初始丢失区间离开丢失历史之后，则不需要采取任何行动。