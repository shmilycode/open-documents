# RTP Payload Format for Generic Forward Error Correction

rfc: 4109

# 简介

本文件规定了RTP封装的媒体数据的通用前向纠错（Forward Error Correction - FEC）的有效载荷格式。它基于异或（奇偶校验）操作。本文档中描述的有效载荷格式允许终端系统使用不同的保护长度和级别进行保护，此外还可以使用不同的保护组大小来适应不同的媒体和信道特性。它可以根据丢包情况，完全恢复受保护的数据包或部分恢复有效载荷的关键部分。该方案与不支持FEC的主机完全兼容，所以多播组中不实现FEC的接收机仍然可以通过简单地忽略保护数据来工作。本规范废除了RFC 2733和RFC 3009。 本文档中指定的FEC与RFC 2733和RFC 3009不向后兼容。

<!-- TOC -->

- [RTP Payload Format for Generic Forward Error Correction](#rtp-payload-format-for-generic-forward-error-correction)
- [简介](#简介)
- [1. 引言](#1-引言)
- [2. 术语](#2-术语)
- [3. 基本操作](#3-基本操作)
- [4.  奇偶校验码](#4--奇偶校验码)
- [5. 非平衡等级保护 Uneven Level Protection(ULP)](#5-非平衡等级保护-uneven-level-protectionulp)
- [6.  RTP媒体包结构](#6--rtp媒体包结构)
- [7.  FEC包结构](#7--fec包结构)
  - [7.1.  包结构](#71--包结构)
  - [7.2. FEC数据包的RTP头](#72-fec数据包的rtp头)
  - [7.3.  FEC包的FEC头](#73--fec包的fec头)

<!-- /TOC -->

# 1. 引言

实时应用的性质意味着它们通常比正常数据传输有更严格的延迟要求。 因此，对丢失的数据包进行重传一般不是此类应用的有效选择，在这些情况下，比较好方法是通过前向纠错（FEC）尝试从丢包中恢复信息。FEC是分组交换网络上防止丢包的主要方法之一[9，10]，特别是使用传统的纠错码，如奇偶校验码、Reed-Solomon码和Hamming码，已经得到广泛应用。要应用这些机制，需要协议的支持。RFC 2733[9]和RFC 3009[11]定义了这样的一些FEC协议。然而，在这两个RFC中，RTP头中的几个字段（P、X和CC字段）的指定方式与RTP[1]中的设计不一致，使得RTP数据包的有效载荷独立性检查无法进行。

本文件扩展了RFC 2733和RFC 3009中定义的FEC，包括对有效载荷数据的不等效错误保护。本规范还修正了上述与 RFC 2733 和 RFC 3009 不一致的地方，并将废止这两个 RFC。请注意，本文指定的有效载荷与 RFC 2733 和 RFC 3009 不兼容。由于本文档中指定的有效载荷是与RFC 3009使用了不同的MIME，因此在能力参数的交换中不存在不同奇偶校验 FEC 版本的误认问题。对于本文档和 RFC 2733 和 RFC 3009 中指定的奇偶校验 FEC，有效载荷数据是不变的，同时会发送额外的 FEC 数据来保护有效载荷数据，因此，实现不同奇偶校验 FEC 版本的主机和没有实现奇偶校验 FEC 的主机之间，有效载荷数据的通信不会出现问题。接收主机与发送主机的FEC不兼容，将无法从额外的FEC数据中获益，因此建议现有的实施RFC 2733和RFC 3009的主机在有可能的情况下应更新为遵循此规范。

本文件定义了RTP的有效载荷格式[1]，允许实时媒体的通用前向纠错。在这种情况下，通用是指FEC协议 (1). 独立于被保护的媒体的性质，无论是音频、视频还是其他；(2). 具有足够的灵活性，以支持各种FEC配置；(3). 为自适应性而设计，以便在没有带外信令的情况下，可以很容易地修改FEC技术；(4). 支持许多不同的机制来传输FEC数据包。

此外，在很多场景下，网络的带宽是非常有限的资源。另一方面，大多数传统的FEC方案并不是为了更好的利用有限的带宽资源而设计的。一个常用的改进方案是非平等错误保护（unequal error protection），它为数据流的不同部分提供不同级别的保护，这些保护的重要性各不相同。非平等错误保护方案通常可以更有效地利用带宽，为数据流提供更好的整体保护，防止丢失。适当的协议支持是实现这些非平等错误保护机制的关键。大多数非平等错误保护方案的应用都需要掌握数据流不同部分的重要性，由于这个原因，这类方案大多需要根据被保护的介质结构，针对特定类型的介质而设计的，因此并不通用。

本文档中定义了FEC算法和协议，用于实时媒体的非平等纠错保护。这里定义的特殊算法称为非平等保护（Uneven Level Protection，ULP）。有效载荷数据由一个或多个保护级别保护，较低的保护级别可以通过使用较小的组大小(与较高的保护级别相比)来生成FEC数据包，从而提供更高的保护。正如我们将在下面讨论的那样，有音视频应用通常会受益于非平等保护方案，这种方案对每个数据包的开头部分给予更多的保护，如ULP。一般来说，离数据包开头较近的数据比较远的数据更重要，也往往携带更多的信息。

众所周知，在很多多媒体流中，数据中比较重要的部分总是在数据包的开头，这是编解码器设计中的普遍做法。这么做的原因是，数据包的开头更接近头部的重新同步标记，因此更有可能被正确解码。此外，几乎所有的媒体格式都将帧头放在数据包的开头，这是数据包中最重要的部分。

对于视频流，大多数现代格式都有可选的数据分区模式，以提高抗错能力，其中视频块头数据、运动矢量数据和离散余弦变换(DCT)系数数据被分离成各自的分区。例如，在ITU-T H.263版本3中，可选的数据分区语法定义在附件V，在MPEG-4 Visual Simple Profile中，也定义了可的选数据分区模式。当启用这些模式时，视频宏块(MB)头和运动矢量分区(这对视频重建的质量更为重要)在视频数据包的起始分区中传输，而残余DCT系数分区(可能不太重要的部分)在接近数据包结束的分区中传输。因为数据是按重要性的递减顺序排列的，所以在传输过程中对数据包的开头部分提供更多的保护是有益的。

对于音频流，许多新的音频编解码器生成的比特流也包含不同重要性等级的数据，这些不同等级的数据是按重要性的递减顺序排列的。在这些情况下，对数据包的开头应用更多的保护也是有益的。 即使对于一致重要性的音频流，也可以对部分恢复的音频数据包应用各种时移和拉伸技术。

音视频应用通常会受益于本文件中规定的FEC算法。通过ULP，可以进一步提高媒体有效载荷的保护效率。本文档规定了将通用FEC应用于RTP媒体有效载荷的协议和算法。

# 2. 术语

本文件中使用了以下术语：

媒体有效载荷：从发送方传送过来的原始的、未受保护的用户数据，媒体有效载荷被放置在RTP包内。

媒体头部：包含媒体有效载荷的数据包的RTP头。

媒体包：媒体有效载荷和媒体头部的组合称为媒体包。

FEC数据包：发送方的FEC算法以媒体数据包为输入，它们既输出它们所传递的媒体数据包，也输出新生成的数据包，称为 FEC 数据包，其中包含用于纠错的冗余媒体数据。FEC包按照本文档中指定的规则进行格式化。

FEC头部：FEC数据包中包含的头信息。

FEC分级头部：每个级别的FEC数据包中包含的头信息。

FEC有效载荷：一个FEC包的有效载荷，它可以分为多个级别。

相关联：当一个或多个媒体数据包被用来生成FEC数据包时，一个FEC数据包被称为与一个或多个媒体数据包 "相关联"(反之亦然)(通过使用异或操作)。如果没有明确说明，它仅指那些用于生成0级FEC有效载荷的数据包。

本文档中的关键词 "MUST"、"MUST NOT"、"REQUIRED"、"SHALL"、"SHALL NOT"、"SHOULD"、"SHOULD NOT"、"RECOMMENDED"、"MAY "和 "OPTIONAL "应按照RFC 2119[2]中的描述进行解释。

# 3. 基本操作

当RTP会话中的发送方希望用通用奇偶校验FEC来保护其发送的媒体流时，就会使用这里描述的有效载荷格式。这种格式所支持的FEC是基于简单的异或（XOR）奇偶运算。发送方从媒体流中抽取需要保护的数据包，并确定这些数据包的保护级别和每个级别的保护长度。这些数据被分组在一起，如下文第7节所述。XOR操作应用于整个有效载荷，生成FEC信息。按照这里定义的步骤，最终产物是包含FEC信息的RTP数据包。这些数据包可以在接收端上用来恢复生成FEC信息的数据包或数据包的一部分。

FEC的有效载荷格式包含的信息，允许发送者准确地告诉接收者哪些媒体数据包受到FEC数据包的保护，以及每个级别的保护等级和长度。具体来说，每个FEC包包含一个偏移量掩码 m(k)，用于保护等级k。如果掩码m(k)中的第i位被设置为1，那么媒体包号N+i在等级k处受到该FEC包的保护。保护长度、偏移掩码、有效载荷类型和序列号基数完全可以识别应用于生成 FEC 包的奇偶校验码，且开销很小，被第k级保护的数据的长度由L(k)表示，它也被包含到FEC包中。在7.4节中描述了一组规则，定义了不同保护级别的掩码应该如何设置，在10节中举例说明。

本文件还介绍了带内传输所有保护操作参数的步骤。这使发送方具有很大的灵活性；发送方可以根据当前的网络条件调整保护措施，并确保接收方仍然可以利用FEC进行恢复。

在接收端上，FEC和原始媒体都被接收。如果没有丢失媒体数据包，则FEC数据包可以被忽略。即使发生丢失，FEC数据包也可以与其他接收到的媒体结合起来，以恢复全部或部分丢失的媒体数据包。

# 4.  奇偶校验码

为了简洁起见，我们将函数f(x,y,...)定义为应用于数据块x,y,...的XOR(奇偶)运算符。这个函数的输出是另一个数据块，称为奇偶校验块。为了简单起见，我们在这里假设奇偶校验块是通过输入块按位XOR计算得到的。具体的计算过程在第8节中说明。

使用奇偶校验码保护数据块，是通过在一组数据块上生成一个或多个奇偶校验块来实现的。为了达到最佳效果，奇偶校验块必须由数据块的线性独立组合生成，这种特殊的组合称为奇偶校验码。有效载荷格式就是使用了XOR奇偶校验码。

例如，考虑一个奇偶检验码在两个数据块上生成一个奇偶校验块。如果原始媒体数据包为a，b，c，d，则发送方生成的数据包为。

      a        b        c        d               <-- media stream
                 f(a,b)            f(c,d)        <-- FEC stream

需要指出的是，除了XOR奇偶校验码之外，还有许多其他类型的外向纠错码也可以用来保护有效载荷。其中一个例子是Reed-Solomon码，还有很多其他的例子[12]。 这里使用XOR奇偶校验码是因为它在协议设计和实现中的有效性和简单性，这对于在资源有限的节点中的实现尤为重要。

# 5. 非平衡等级保护 Uneven Level Protection(ULP)

从上面的简单例子可以看出，对数据的保护取决于组的大小。在上面的例子中，组的大小是2，所以如果三个数据包（两个有效载荷包和一个FEC包）中的任何一个丢失了，原来的有效载荷数据都可以恢复。

一般来说，FEC保护操作是在带宽和保护强度之间进行权衡。作为源媒体数据包的一部分，产生的FEC数据包越多，防丢保护力度越大，但组合流消耗的带宽也越大。

在大多数媒体有效载荷中，并非所有的数据包部分都具有相同的重要性，利用这一特性，可以更有效地利用信道带宽。即通过采用不平等的错误保护，对数据包的不同部分采用不同的保护，这样更多的带宽用于保护比较重要的部分，而较少的带宽用于保护不重要的部分。

数据包根据重要性递减的被分成多个部分，每个部分会被应用不同强度的保护，这些部分被称为 "级别"。保护操作是独立地应用在每个级别上的，一个FEC数据包可以携带多个级别的部分数据。这种算法称为非平衡等级保护，或ULP。

ULP的保护情况如下图1所示。 在这个例子中，两个ULP FEC数据包在保护四个有效载荷数据包。

ULP FEC包 #1 只有一个级别，它保护的是包A和包B，它不对A和B的整个包进行奇偶校验操作，而只保护两个包的一个指定长度的数据，这个长度可以在会话中动态选择和改变，称为保护长度。

ULP FEC数据包 #2 具有两个保护级别。 级别0保护与ULP FEC数据包 #1 相同，只是它在数据包C和D上操作。级别1保护使用的是奇偶校验操作，该奇偶校验操作应用于数据包A，B，C和D的数据。级别1保护在与级别0不同的一组数据包上运行，并且与级别0具有不同的保护长度，其他任何级别也是如此。信息全部通过本文档中指定的协议进行带内传送。

         Packet A          #####################
                                  :        :
         Packet B          ############### :
                                  :        :
         ULP FEC Packet #1 @@@@@@@@        :
                                  :        :
         Packet C          ###########     :
                                  :        :
         Packet D          ###################################
                                  :        :
         ULP FEC Packet #2 @@@@@@@@@@@@@@@@@
                           :      :        :
                           :<-L0->:<--L1-->:

                        图1：Unequal Level Protection

正如我们在前言中所讨论的那样，数据包的开头是媒体流更重要的部分。通常情况下，对靠近数据包开头的层级提供较强的保护，而在后面的层级提供较弱的保护是非常有用的，ULP算法提供了这样的FEC保护。

ULP FEC不仅为数据包的开头提供了更多的保护(这一点比较重要)，还尽可能地避免了数据包的前一部分无法恢复，而后一部分可以恢复(而且往往必须丢弃)的情况，这样的效率比较低。

# 6.  RTP媒体包结构

媒体包的格式不受FEC的影响。如果FEC作为一个单独的流发送，媒体包像没有FEC一样发送。

这种方法的优点是，媒体包可以被不支持FEC的接收方解析。这种与不支持FEC的接收方的兼容性在多播方案中特别有用。使用FEC方案的开销只存在于FEC数据包中，通过跟踪使用中的FEC数量，可以很容易地监控和调整。

# 7.  FEC包结构

## 7.1.  包结构

FEC包的构造是将一个FEC头和一个或多个级别的FEC头和有效载荷放入RTP有效载荷中，如图2所示：

    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    |                RTP Header (12 octets or more)                 |
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    |                    FEC Header (10 octets)                     |
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    |                      FEC Level 0 Header                       |
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    |                     FEC Level 0 Payload                       |
    |                                                               |
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    |                      FEC Level 1 Header                       |
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    |                     FEC Level 1 Payload                       |
    |                                                               |
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    |                            Cont.                              |
    |                                                               |
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

                            图2：FEC数据包结构

## 7.2. FEC数据包的RTP头

FEC数据包的RTP头只在FEC与受保护的有效载荷流（如第14节所定义）分开发送时使用。因此，下面的大部分讨论只适用于这种情况。FEC包的RTP头中的所有字段都是根据RFC 3550[1]使用的，其中一些字段在下文中进一步说明。

掩码：此字段不用于此有效载荷类型，应置0。

同步源（SSRC）：SSRC值应与其保护的媒体流的SSRC值相同。

序列号（SN）：序列号有标准定义 -- 必须比之前发送的FEC包中的序列号高一个。

时间戳（TS）：时间戳必须设置为FEC数据包传输时媒体RTP时钟的值。因此，FEC数据包中的TS值总是单调地增加。

有效载荷类型：FEC数据包的有效载荷类型是通过带外方式动态确定的。根据RFC 3550[1]，不能识别有效载荷类型的RTP参与方必须丢弃它。然后，FEC机制可以在混合了具有和不具有FEC能力的接收方的多播组中使用，特别是当FEC保护作为冗余编码发送时（见第14节）。在这种情况下，FEC保护的有效载荷类型将不被不具有FEC能力接收方识别，而是直接忽略。

## 7.3.  FEC包的FEC头

FEC头占10字节 头的格式如图3所示，由扩展标志（E位）、长掩码标志（Lbit）、P恢复字段、X恢复字段、CC恢复字段、M恢复字段、PT恢复字段、SN基字段、TS恢复字段和长度恢复字段组成。

     0                   1                   2                   3
     0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    |E|L|P|X|  CC   |M| PT recovery |            SN base            |
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    |                          TS recovery                          |
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    |        length recovery        |
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

                            图3：FEC头格式

E位是保留的扩展标志，表示将来对本规范的任何扩展，它应该被设置为0，并且应该被接收方忽略。

L位表示是否使用了长掩码，当L位未设置时，掩码为16位，而当L位被设置时，掩码为48位长。

P恢复字段、X恢复字段、CC恢复字段、M恢复字段和PT恢复字段是通过对与FEC包相关的媒体包的RTP头中相应的P、X、CC、M和PT值进行保护操作获得的。

SN基字段必须设置为受FEC保护的媒体数据包（在所有级别）中的最低序列号，并考虑到包环绕的问题。这样，当L字段设置为0时，FEC操作可以扩展到最多16个数据包的任何字符串上，或者当L字段设置为1时，可以扩展到48个数据包上，以此类推。

TS恢复字段是通过对与该FEC包相关的媒体包的时间戳进行保护操作计算得到的，这样可以完全恢复时间戳。

长度恢复字段用于确定所有恢复的数据包的长度。它是通过对媒体一系列数据的和的无符号网络顺序16位表示的保护操作计算出来的，包括有效载荷、CSRC 列表、扩展和与该 FEC 数据包相关的每个媒体数据包的填充长度（以字节为单位）（换句话说，媒体有效载荷数据包的 CSRC 列表、RTP 扩展和填充（如果存在）被 "计算 "为有效载荷的一部分）。这使得FEC程序即使在受保护的媒体数据包的长度不相同时也能应用。例如，假设一个FEC数据包是由两个媒体数据包一起异或生成的，两个媒体包的有效载荷长度分别为3(0b011)和5(0b101)字节，长度恢复字段被编码为0b011 xor 0b101 = 0b110。

7.4.  FEC包的FEC分级报头

FEC分级报头为4个或8个字节（取决于FEC报头中的L位）。头文件的格式如图4所示。

FEC分级头部由保护长度字段和掩码字段组成。保护长度字段长16位。掩码字段长16位（未设置L位时）或48位（设置L位时）。

FEC 分级头中的掩码字段表示哪些数据包与当前级别的 FEC 数据包相关联，它是 16 或 48 位，取决于 L 位的值。 如果掩码中的i位被设置为1，则序列号为N+i的媒体包与该FEC包相关联，其中N是FEC包头中的SN Base字段。掩码中最重要的位对应i=0，当L位设置为0时，最不重要的位对应i=15，当L位设置为1时，i=47。

     0                   1                   2                   3
     0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    |       Protection Length       |             mask              |
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    |              mask cont. (present only when L = 1)             |
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

                            图4：ULP分级头部格式
            
掩码字段的设置应遵循以下规则。

    a. 一个媒体数据包在高于0级的每一个保护级别上只能被保护一次，一个媒体数据包在0级可由不同的数据包保护一次以上，但这些数据包的0级保护长度字段必须相等。

    b. 要使一个媒体数据包得到p级保护，它在任何FEC数据包中也必须得到p-1级的保护。请注意，媒体数据包的保护级别p可以在一个与同一媒体数据包的保护级别p-1不同的FEC数据包中，。

    c. 如果一个ULP FEC数据包包含p级的保护，它必须包含p-1级的保护。请注意，p级保护的有效载荷数据包的组合可能不同于p-1级的数据包。

规则(a)的理由是，多重保护增加了恢复实现的复杂性。在更高的级别上，多重保护提供的好处越来越少，因此其应用被限制在0级，以简化实现。规则(b)的基本原理是保护偏移(对于每个相关的数据包)在协议中没有明确的指示，有了这个限制，偏移量可以很容易地从各等级的保护长度中扣除。规则(c)的基本原理是保护级别没有明确表示，该规则的设置是为了隐式地指定级别。

下面的图5中说明了保护组合的一个例子。它与图1所示的例子相同，在第10.2节中也更详细地展示了这个示例，以说明如何设置标题中的字段。

数据包A

         Payload packet #  |  ULP FEC packet that protects at level
                           |          L0             L1
      ---------------------+---------------------------------------
                A          |          #1             #2
                B          |          #1             #2
                C          |          #2             #2
                D          |          #2             #2

                            图5：一个保护组合的例子
              
在这个例子中，ULP FEC数据包。

各级ULP FEC数据包的有效载荷是应用于该级ULP FEC数据包相关的介质有效载荷和填充的保护操作（XOR）。 详细内容在第8节保护操作中描述。
ULP FEC数据包的大小由保护操作选择的保护长度决定。 在上面的例子中，ULP FEC包的大小是由保护操作所选择的保护长度决定的。
请注意，FEC数据包（非ULP和ULP）有可能比它所保护的最长媒体数据包大，这是因为来自报头的开销，或者如果为ULP选择了一个大的保护长度。 如果这导致FEC数据包超过其发送路径的最大传输单元大小，就会造成困难。
8.  保护操作FEC包是由受保护媒体RTP包的数据生成的 "FEC位串 "形成的。 具体来说，FEC位串是受保护媒体RTP包的 "受保护位串 "的位独占OR。
在进行保护操作时，可以遵循以下程序，也可以使用其他程序，但最终结果必须与此处描述的相同。
8.1.  在FEC头的情况下，在FEC级别0时，为每个要保护的媒体数据包生成受保护的位串（长度为80位）。 它是由以下字段按指定的顺序连在一起形成的。
o RTP头的前64位(64位)o 无符号网络排序的16位mediapacket长度的字节减去12(对于固定的RTP头)，即以下所有长度的总和(如果存在的话)：CSRC列表、扩展头、RTP有效载荷和RTP填充(16位)在通过对受保护的位串进行奇偶校验操作形成FEC位串后，FEC头由FEC位串生成，如下所示。
FEC位串中的前2位(最重要的)被跳过。 FEC位串中的下一位被写入FEC包中FEC头的Precovery位。 FEC位串中的下一个位被写入FEC头的E恢复位。 FEC位串的下一个4位被写入FEC头的CC恢复域。 下一个位被写入FEC头的M恢复位。 接下来的7位FEC位串被写入FEC头的PT恢复字段，接下来的16位被跳过。 接下来的16位被跳过。 接下来的32位FEC位串被写入FEC头的TS恢复字段。 接下来的16位被写入包头中的长度恢复字段。
8.2.  FEC有效载荷的生成对于FEC有效载荷的生成，受保护的位串就是受保护的RTP数据包，因此FEC位串是这些受保护的媒体RTP数据包的位独占OR。 因此，FEC位串是这些受保护媒体RTP包的位独占OR。 这样的FEC位串需要为每一级生成，因为每一级的受保护的有效载荷数据包组可能不同。 如果受保护的RTP包的长度不相等，每个较短的包必须在末尾添加字节0来填充到最长的包的长度。
对于保护级别n(n=0，1，......)，只有Ln八位字节的数据被设置为n级ULP头后的FEC级别n有效载荷数据，该数据是指从FEC位串中的(Sn+13)th八位字节开始的Ln八位字节的数据，其中。
Sn = sum(Li : 0 <= i < n).
Li是第i级的保护长度，S0定义为0.省略前12个八位字节的原因是该信息已经受到FEC头的保护。
9.  恢复程序FEC包允许终端系统从介质包的丢失中恢复。 本节描述了执行这种恢复的程序。
恢复需要两个不同的操作。 第一步是确定哪些数据包（媒体和FEC）必须合并，以便恢复丢失的数据包。 一旦这样做，第二步是实际重建数据。 第二步必须如下面所述进行。 第一步可以基于任何算法，由实施者选择。 不同的算法会导致复杂度和恢复丢失数据包的能力之间的权衡，如果可能的话。
丢失的有效载荷数据包可以全部恢复，也可以部分恢复，这取决于由于不等差错保护的性质(当它被使用时)造成的数据丢失情况。 可以通过检查从FEC头中检索到的数据包的恢复长度与实际恢复的有效载荷数据的长度来检测数据包的部分恢复。
9.1.  RTP头的重构让T成为可以组合起来的数据包列表(FEC和媒体)，以恢复0级的一些媒体数据包xi。 其过程如下。
1.  对于T中的媒体数据包，按照上一节所述的生成FEC头的过程，计算受保护位串的前80位。
2.  对于T中的FEC包，FEC位串是80位的FECheader。
3.  计算恢复位串为T中所有mediapackets产生的保护位串和T中所有FECpackets产生的FEC位串的位独占OR。
4.  创建一个新的数据包，包含标准的12字节RTP头，不包含有效载荷。
5.  将新数据包的版本设置为2，跳过恢复位串的前2位。
6.  将新数据包中的Padding位设置为Recovery位字符串中的下一个位。
7.  将新数据包中的Extension位设置为Recovery位串中的下一个位。
8.  将CC字段设置为恢复位串中的下4位。
9.  将新数据包中的标记位设置为恢复位串中的下一个位。
10. 将新数据包中的有效载荷类型设置为恢复位串中的后7位。
11. 将新数据包中的SN字段设置为xi。 跳过恢复位字符串中的下一个16bits。
12. 将新数据包中的TS字段设置为恢复位串中的下一个32位。
13. 取恢复位字符串的后16位。 无论这代表的是什么无符号整数(假设网络顺序)，都从恢复位串中取出这么多字节，并将它们附加到新的数据包中。 这代表CSRC列表、扩展、有效载荷和RTP有效载荷的填充。
14. 将新数据包的SSRC设置为它所保护的媒体流的SSRC，即媒体流的SSRC与FEC流相关联。
这个过程将恢复RTP包的头，直到SSRC字段。
9.2.  RTP有效载荷的重构让T成为在一定保护级别下可以组合起来恢复某个媒体包xi的数据包列表（FEC和媒体）。 Theprocedure如下。
1.  假设我们要重建n级的数据，第一步是从n级的ULP头中得到n级的保护长度(Ln)。
2.  对于T中的FEC包，级别n的FEC位串为FEClevel n有效载荷，即级别n的ULPheader后面的Ln八位字节数据。
3.  对于T中的媒体数据包，leveln的保护位串是以(Sn+13)th八位字节开始的Ln八位字节数据。 Sn与第8.2节中的定义相同。 注意，0级的保护是从SSRC字段之后的第13个八位字节开始的。 前 12 个八位字节的信息由 FEC 头保护。
4.  如果从媒体包中产生的n级保护位串比当前级别的保护长度短，则将其垫到该长度。 填充的0号字节必须加在比特串的最后。
5.  计算恢复位串为T中所有媒体数据包产生的n级受保护位串和T中所有FEC数据包产生的n级FEC位串的bitwise exclusive ORof。
6.  上文产生的当前保护级别的恢复位串与所有其他级别的恢复位串连接起来，形成（完全或部分）恢复的媒体数据包。 请注意，根据保护长度的设置，每个保护级别的恢复位串必须放在该级别恢复介质包的正确位置。
7.  恢复的媒体数据包的总长度是从该媒体数据包的保护级别0的恢复操作中恢复出来的。 此信息可用于检查完整的恢复操作(所有级别)是否已将数据包恢复到其全长。
在大多数情况下，如果上一级保护的数据可以恢复，那么在较低保护级别保护的数据是可以恢复的。 这个过程(和低级保护级别的过程一起)通常可以恢复RTP包的头和有效载荷，直到当前级别的保护长度。
10.  在下面考虑的前两个例子中(第10.1和10.2节)，我们假设FEC流是通过一个单独的RTPsession发送的，如第14.1节所述。 在这些例子中，我们假设有四个媒体数据包要从SSRC 2发送，分别是A、B、C和D，它们的序列号分别是8、9、10和11，时间戳分别是3、5、7和9。 数据包A和C使用有效载荷类型11，数据包B和D使用有效载荷类型18.它们的序列号分别为8、9、10和11，数据包的时间戳分别为3、5、7和9。 包Ahas200字节的有效载荷，包B140，包C100，包D340。 数据包A和C的标记位被设置。
第三个例子（第10.3节）是说明当FEC数据作为冗余数据与有效载荷包一起发送时。
10.1.  一个例子提供了与RFC 2733类似的保护我们可以用一个FEC包在一个级别中保护四个有效载荷包的全部长度。 这提供了与RFC 2733类似的保护。 方案如图6所示。
                    +-------------------+             :
         Packet A   |                   |             :
                    +-------------+-----+             :
         Packet B   |             |                   :
                    +---------+---+                   :
         Packet C   |         |                       :
                    +---------+-----------------------+
         Packet D   |                                 |
                    +---------------------------------+
                                                      :
                    +---------------------------------+
         Packet FEC |                                 |
                    +---------------------------------+
                    :                                 :
                    :<------------- L0 -------------->:
图6：具有单层保护的FEC方案一个FEC包由这四个数据包产生，我们假设payload类型127用来表示一个FEC包。 我们假设用payload类型127来表示一个FEC包。 生成的RTP头如图7所示。
FEC包中的FEC头如图8所示。
0级的FEC级头如图9所示。
    0                   1                   2                   3
    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |1 0|0|0|0 0 0 0|0|1 1 1 1 1 1 1|0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1|
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 1|
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0|
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
      Version:   2
      Padding:   0
      Extension: 0
      Marker:    0
      PT:        127
      SN:        1
      TS:        9
      SSRC:      2
                  Figure 7: RTP Header of FEC Packet
    0                   1                   2                   3
    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |0|0|0|0|0 0 0 0|0|0 0 0 0 0 0 0|0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0|
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0|
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |0 0 0 0 0 0 0 1 0 1 1 1 0 1 0 0|
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
      E:         0     [this specification]
      L:         0     [short 16-bit mask]
      P rec.:    0     [0 XOR 0 XOR 0 XOR 0]
      X rec.:    0     [0 XOR 0 XOR 0 XOR 0]
      CC rec.:   0     [0 XOR 0 XOR 0 XOR 0]
      M rec.:    0     [1 XOR 0 XOR 1 XOR 0]
      PT rec.:   0     [11 XOR 18 XOR 11 XOR 18]
      SN base:   8     [min(8,9,10,11)]
      TS rec.:   8     [3 XOR 5 XOR 7 XOR 9]
      len. rec.: 372   [200 XOR 140 XOR 100 XOR 340]
               Figure 8: FEC Header of FEC Packet
    0                   1                   2                   3
    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |0 0 0 0 0 0 0 1 0 1 0 1 0 1 0 0|1 1 1 1 0 0 0 0 0 0 0 0 0 0 0 0|
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
L0：340[200、140、100和340中最长的一个]掩码。     61440 [Bits 1, 2, 3, 4相应地标记为Packet 8, 9, 10, 11]0级的有效载荷长度为340字节。
图9：FEC级别头（0级）10.2.  一个有两个保护级别的例子一个更复杂的例子是在两个级别上使用FEC。 0级FEC将对有效载荷包的起始部分提供更大的保护。 1级FEC将对数据包的最后部分提供额外的保护。 这在图10中得到了说明。 在这个例子中，L0=70，L1=90。
              +------:--------:---+
   Packet A   |      :        :   |
              +------:------+-:---+
   Packet B   |      :      | :
              +------:--+---+ :
                     :        :
              +------+        :
   ULP #1     |      |        :
              +------+        :
                     :        :
              +------:--+     :
   Packet C   |      :  |     :
              +------:--+-----:-----------------+
   Packet D   |      :        :                 |
              +------:--------:-----------------+
                     :        :
              +------:--------+
   ULP #2     |      :        |
              +------:--------+
              :      :        :
              :<-L0->:<--L1-->:
图10：保护级别为0和1的ULP FEC方案这将导致两个FEC数据包------。
由此产生的ULP FEC数据包
    0                   1                   2                   3
    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |1 0|0|0|0 0 0 0|1|1 1 1 1 1 1 1|0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1|
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 1|
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0|
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
      Version:   2
      Padding:   0
      Extension: 0
      Marker:    1
      PT:        127
      SN:        1
      TS:        5
      SSRC:      2
               Figure 11: RTP Header of FEC Packet #1
    0                   1                   2                   3
    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |0|0|0|0|0 0 0 0|0|0 0 1 1 0 0 1|0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0|
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 1 0|
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |0 0 0 0 0 0 0 0 0 1 0 0 0 1 0 0|
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
      E:         0     [this specification]
      L:         0     [short 16-bit mask]
      P rec.:    0     [0 XOR 0 XOR 0 XOR 0]
      X rec.:    0     [0 XOR 0 XOR 0 XOR 0]
      CC rec.:   0     [0 XOR 0 XOR 0 XOR 0]
      M rec.:    0     [1 XOR 0 XOR 1 XOR 0]
      PT rec.:   25    [11 XOR 18]
      SN base:   8     [min(8,9)]
      TS rec.:   6     [3 XOR 5]
      len. rec.: 68    [200 XOR 140]
               Figure 12: FEC Header of ULP FEC Packet #1
    0                   1                   2                   3
    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |0 0 0 0 0 0 0 0 0 1 0 0 0 1 1 0|1 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0|
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
L0：70mask:      49152[对于包8和包9，Bits 1和2也有相应的标记]0级的有效载荷长度为70字节。
图13：FEC包的FEC级别头(0级)
    0                   1                   2                   3
    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |1 0|0|0|0 0 0 0|1|1 1 1 1 1 1 1|0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0|
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 1|
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0|
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
      Version:   2
      Padding:   0
      Extension: 0
      Marker:    1
      PT:        127
      SN:        2
      TS:        9
      SSRC:      2
                Figure 14: RTP Header of FEC Packet #2
    0                   1                   2                   3
    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |0|0|0|0|0 0 0 0|0|0 0 1 1 0 0 1|0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0|
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 1 1 0|
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |0 0 0 0 0 0 0 1 0 0 1 1 0 0 0 0|
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
      E:         0     [this specification]
      L:         0     [short 16-bit mask]
      P rec.:    0     [0 XOR 0 XOR 0 XOR 0]
      X rec.:    0     [0 XOR 0 XOR 0 XOR 0]
      CC rec.:   0     [0 XOR 0 XOR 0 XOR 0]
      M rec.:    0     [1 XOR 0 XOR 1 XOR 0]
      PT rec.:   25    [11 XOR 18]
      SN base:   8     [min(8,9,10,11)]
      TS rec.:   14    [7 XOR 9]
      len. rec.: 304   [100 XOR 340]
               Figure 15: FEC Header of FEC Packet #2
    0                   1                   2                   3
    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |0 0 0 0 0 0 0 0 0 1 0 0 0 1 1 0|0 0 1 1 0 0 0 0 0 0 0 0 0 0 0 0|
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
L0：70mask。     12288[对于第10和第11包，第3和第4位有相应的标记]0级的有效载荷长度为70字节。
      Figure 16: FEC Level Header (Level 0) for FEC Packet #2
    0                   1                   2                   3
    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |0 0 0 0 0 0 0 0 0 1 0 1 1 0 1 0|1 1 1 1 0 0 0 0 0 0 0 0 0 0 0 0|
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
L1: 90mask:      61440[第8、9、10、11包的第1、2、3、4位有相应的标记]第1级的有效载荷长度为90字节。
图17：FEC包的FEC级别标头（1级
我们使用的FEC方案将与一级，如10.1节图6所示。 保护长度L0=340八位数。
采用冗余编码分组，有效载荷类型为100。 假设FEC的payload类型为127。 前四个RED包，RED
红包
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                 RTP Header (RED) - 6 octets                   |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |        Primary Encoding Block Header (RED) - 1 octet          |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                      Media Packet Data                        |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
          Figure 18: RED Packet Structure - Media Data Only
    0                   1                   2                   3
    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |1 0|0|0|0 0 0 0|0|1 1 0 0 1 0 0|0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1|
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 1|
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0|
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
      Version:   2
      Padding:   0
      Extension: 0
      Marker:    0     [Even though media packet A has marker set]
      PT:        100   [Payload type for RED]
      SN:        1
      TS:        5
      SSRC:      2
               Figure 19: RTP Header of RED Packet #1
    0 1 2 3 4 5 6 7
   +-+-+-+-+-+-+-+-+
   |0|0 0 0 1 0 1 1|
   +-+-+-+-+-+-+-+-+
F位。    0[这是初级编码数据]Block PT：11[媒体的有效载荷类型]图20：初级编码块头FEC数据不是直接从RED包中生成的，而是从包含媒体包数据的虚拟RTP包中生成的。 Thosevirtual RTP packets can be very easily generated from the RED packetsboth with and without redundant coding included.  从RED数据包到虚拟RTP数据包的转换只需通过以下方式完成：(1)删除任何RED块头和冗余编码数据，(2)用主编码的PT替换RTP头中的PT。
注：在RFC 2198规定的冗余编码的有效载荷格式中，一旦RED数据包中携带了主编码，标记位就会丢失。 所以无论是否使用FEC，标记位都不能恢复。
如上所述，红包
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                 RTP Header (RED) - 6 octets                   |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |       Redundant Encoding Block Header (RED) - 4 octets        |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                        FEC Packet Data                        |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |        Primary Encoding Block Header (RED) - 1 octet          |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                       Media Packet Data                       |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
图21：RED数据包结构--包含FEC数据包含FEC的RED数据包的RTP报头与图19所示相同，有相应的序列号和时间戳。
在红包中
    0                   1                   2                   3
    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |1|1 1 1 1 1 1 1|0 0 0 0 0 0 0 0 0 0 0 0 0 0|0 1 0 1 1 0 0 0 1 0|
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
F位。    1[这是冗余编码数据]Block PT：127[FEC的动态有效载荷类型]TS Offset：0[FEC数据传输的实例]Block Len：354[FEC头(10个八位字节)加上ULP 0级头(4个八位字节)和ULP 0级数据(340个八位字节)]图22：冗余编码块头11.  安全考虑在安全通信中使用FEC与加密有两种方式：一种方式是在已经加密的payloads上应用FEC，另一种方式是在加密之前应用FEC。 第一种情况是在媒体数据加密后，在传输过程中需要FEC的时候，会遇到anot可信节点。 第二种情况是当媒体数据在通过安全传输之前就被FEC保护了。
由于该FEC的保护有效载荷是RTP数据包，因此在加密有效载荷上应用FEC主要适用于secureRTP（SRTP）的情况[13]。 因为FEC在有效载荷上应用XOR，所以FEC数据包在密码学上应该和原始payload一样安全。 在这种情况下，FEC数据包的额外加密是没有必要的。
在下面的讨论中，假设FEC是在加密前应用于有效载荷。 FEC的使用对加密密钥的使用和更改有影响。 由于FEC数据包是由一个独立的数据流组成的，因此在加密的使用上有多种组合。 这些组合包括：
o FEC流可以加密，而媒体流不加密。
o 媒体流可以加密，而FEC流不加密。
o 媒体流和FEC流都是加密的，但使用相同的密钥。
o 媒体流和FEC流都是加密的，但使用不同的密钥。
其中前三种情况需要所有应用级信令协议了解FEC的使用情况，从而分别在媒体和FEC流上交换密钥和协商加密用法。 在最后一种情况下，不需要这种额外的机制。 前两种情况存在分层违规，因为ULPFEC数据包的处理方式应该与其他RTP数据包没有区别，只加密一个流也可能使某些已知的明文攻击成为可能。 由于这些原因，利用加密的应用程序应该对两个流进行加密，即最后两个选项。
此外，由于对于某些密码来说，媒体有效载荷和FEC数据之间的已知关系可能会削弱加密效果，因此，当媒体有效载荷和FEC数据以单独的流发送时，每个流必须使用不同的加密密钥。 请注意，当SRTP[13]用于RTP会话的安全时，SRTP规范要求每个RTP会话使用不同的密钥。
加密密钥的改变是另一个需要解决的关键问题。 考虑这样的情况：两个数据包a和b与保护它们的FEC数据包一起出现。 用于加密a和b的密钥是不同的，那么应该用哪个密钥来解码FEC数据包呢？ 一般来说，旧的密钥需要被缓存，这样当媒体流的密钥发生变化时，旧的密钥可以被使用，直到确定ULP FEC数据包的密钥也发生了变化。 此外，新密钥应该用于加密由新旧密钥加密的有效载荷数据包组合产生的FEC数据包。 发送方和接收方需要定义如何进行加密和如何使用密钥。
改变FEC数据和数据包会对重建操作产生很大影响。 通过改变FECdata中的某些位进行攻击，会对有效载荷数据包的计算和恢复产生重大影响。 例如，改变lengthrecovery字段会导致恢复的数据包是工具性的。 另外，恢复的计算复杂度很容易受到影响，最多影响一个数量级。 根据应用场景，在执行恢复操作之前，对接收到的有效载荷和FEC数据进行理智检查，并在使用它们之前确定恢复操作中恢复数据的有效性，可能会有所帮助。
12.  拥塞的考虑使用FEC的另一个问题是它对网络拥塞的影响。 在许多情况下，网络中的数据包丢失是由拥塞引起的。 在这种情况下，应该避免在遇到网络损失增加时增加FEC。 如果它被广泛使用，可能会导致拥塞增加和最终的拥塞崩溃。 应用可能包括更强的保护措施，同时减少有效载荷数据包的带宽。 在任何情况下，随着网络损耗的增加，实施方案都不能大幅增加使用中的总带宽（包括有效载荷和FEC）。
传输RTP数据的一般拥塞控制考虑因素适用；见RTP[1]和任何适用的RTP配置文件（如RTPAVP[14]）。 如果使用了最佳努力服务，还有一个额外的要求是，这种有效载荷格式的用户必须监控丢包，以确保丢包率在可接受的参数范围内，如果一个TCP流通过同一条网络路径，并经历同样的网络条件，在合理的时间尺度上测量的平均吞吐量不低于RTP流实现的吞吐量，则认为丢包是可接受的。 这个条件可以通过实施拥塞控制机制来适应传输速率(或分层多播会话的订阅层数)，或在损失率高得不可接受的情况下安排接收方离开会话来满足。
13.  IANA的考虑因素如本节所述，已经在IANA注册了四个新的媒体子类型。 这种注册是使用注册模板[3]并遵循RFC 3555[4]进行的。
13.1.  注册audioulpfec类型名称：音频子类型名称：ulpfec所需参数。
速率。RTP时间戳率，用于标记独立流中FEC包的传输时间。 在它作为冗余数据被发送到另一个流的情况下，速率应与它用来保护的主编码相同。当在一个单独的流中使用时，速率应大于1000Hz，以便为RTCP操作提供足够的分辨率。 这些选择的速率可以是高于1000Hz的任何值，但建议与这个流保护的媒体的速率相匹配。
可选参数：
onelevelonly。指定是否只使用一个级别的FEC保护，允许的值是0和1。 允许的值是 0 和 1。 如果发出 1 的信号，流中只能使用一个级别的 FEC 保护。 如果发出0信号，则可以使用一个以上的FEC保护级别。如果省略，它的默认值为0。
编码考虑。这种格式是有框架的(见模板文件[3]第4.8节)，包含二进制数据。
安全考虑。RFC 5109号文件详述的安全考虑因素同样适用于这些媒体类型的登记。
互操作性考虑：无已发布的规范。RFC 5109使用这种媒体类型的应用。通过在媒体流中发送额外的数据来提高损失弹性的多媒体应用。
附加信息：无更多信息请联系Adam Li adamli@hyervision.comIETF AudioVideo Transport Working Group预期用途。COMMON使用限制：该媒体类型取决于RTP帧，因此只定义为通过RTP[RTP]传输。此媒体类型取决于RTP框架，因此只定义为通过RTP传输[1]。 在其他帧协议中的传输不应定义，因为这是RTP的稳健性机制。
作者:Adam Li adamli@hyervision.comChange controller:IETF音视频传输工作组委托IESG。
13.2.  注册videoulpfec类型名称：视频子类型名称：ulpfec所需参数。
速率。RTP时间戳率，用于标记独立流中FEC包的传输时间。 在它作为冗余数据发送到另一个流的情况下，速率应与它用来保护的主编码相同。当用于单独的流时，速率应大于1000Hz，以便为RTCP操作提供足够的分辨率。 这些选择的速率可以是高于1000Hz的任何值，但建议与该流保护的媒体的速率相匹配。
可选参数：
onelevelonly。指定是否只使用一个级别的FEC保护，允许的值是0和1。 允许的值是 0 和 1。 如果发出 1 的信号，流中只能使用一个级别的 FEC 保护。 如果发出0信号，则可以使用一个以上的FEC保护级别。如果省略，它的默认值为0。
编码考虑。这种格式是有框架的(见模板文件[3]第4.8节)，包含二进制数据。
安全考虑。RFC 5109号文件详述的安全考虑因素同样适用于这些媒体类型的登记。
互操作性考虑：无已发布的规范。RFC 5109使用这种媒体类型的应用。通过在媒体流中发送额外的数据来提高损失弹性的多媒体应用。
附加信息：无更多信息请联系Adam Li adamli@hyervision.comIETF AudioVideo Transport Working Group预期用途。COMMON使用限制：该媒体类型依赖于RTP帧，因此仅定义为通过RTP[1]进行传输。此媒体类型依赖于RTP框架，因此仅定义为通过RTP传输[1]。 在其他成帧协议中的传输不应定义，因为这是RTP的稳健性机制。
作者：Adam Li adamli@hyervision.comChange 控制器：IETF AudioVideo Transport Working Groupdelegated from the IESG.
13.3.  注册textulpfec类型名称：text子类型名称：ulpfec所需参数。
速率。RTP时间戳率，用于标记独立流中FEC包的传输时间。 在它作为冗余数据发送到另一个流的情况下，速率应与它用来保护的主编码相同。当用于单独的流时，速率应大于1000Hz，以便为RTCP操作提供足够的分辨率。 这些选择的速率可以是高于1000Hz的任何值，但建议与该流保护的媒体的速率相匹配。
可选参数：
onelevelonly。指定是否只使用一个级别的FEC保护，允许的值是0和1。 允许的值是 0 和 1。 如果发出 1 的信号，流中只能使用一个级别的 FEC 保护。 如果发出0信号，则可以使用一个以上的FEC保护级别。如果省略，它的默认值为0。
编码考虑。这种格式是有框架的(见模板文件[3]第4.8节)，包含二进制数据。
安全考虑。RFC 5109号文件详述的安全考虑因素同样适用于这些媒体类型的登记。
互操作性考虑：无已发布的规范。RFC 5109使用这种媒体类型的应用。通过在媒体流中发送额外的数据来提高损失弹性的多媒体应用。
附加信息：无更多信息请联系Adam Li adamli@hyervision.comIETF AudioVideo Transport Working Group预期用途。COMMON使用限制：该媒体类型依赖于RTP帧，因此仅定义为通过RTP[1]进行传输。此媒体类型依赖于RTP框架，因此仅定义为通过RTP传输[1]。 在其他成帧协议中的传输不应定义，因为这是RTP的稳健性机制。
作者:Adam Li adamli@hyervision.comChange controller:IETF音视频传输工作组委托IESG。
13.4.  注册应用ulpfec类型名称：应用子类型名称：ulpfec所需参数。
速率。RTP时间戳率，用于标记独立流中FEC包的传输时间。 在它作为冗余数据发送到另一个流的情况下，速率应与它用来保护的主编码相同。当用于单独的流时，速率应大于1000Hz，以便为RTCP操作提供足够的分辨率。 这些选择的速率可以是高于1000Hz的任何值，但建议与该流保护的媒体的速率相匹配。
可选参数：
onelevelonly。指定是否只使用一个级别的FEC保护，允许的值是0和1。 允许的值是 0 和 1。 如果发出 1 的信号，流中只能使用一个级别的 FEC 保护。 如果发出0信号，则可以使用一个以上的FEC保护级别。如果省略，它的默认值为0。
编码考虑。这种格式是有框架的(见模板文件[3]第4.8节)，包含二进制数据。
安全考虑。RFC 5109号文件详述的安全考虑因素同样适用于这些媒体类型的登记。
互操作性考虑：无已发布的规范。RFC 5109使用这种媒体类型的应用。通过在媒体流中发送额外的数据来提高损失弹性的多媒体应用。
附加信息：无更多信息请联系Adam Li adamli@hyervision.comIETF AudioVideo Transport Working Group预期用途。COMMON使用限制：该媒体类型依赖于RTP帧，因此仅定义为通过RTP[1]进行传输。此媒体类型依赖于RTP框架，因此仅定义为通过RTP传输[1]。 在其他成帧协议中的传输不应定义，因为这是RTP的稳健性机制。
作者:Adam Li adamli@hyervision.comChange controller:IETF音视频传输工作组委托IESG。

14.1.  FEC作为一个单独的流当FEC数据包以一个单独的流发送时，必须传达几条信息。
o FEC的地址和端口 FEC的有效载荷类型号FECo FEC保护的媒体流FEC没有静态的有效载荷类型分配，所以必须使用动态的有效载荷类型号。 FEC流的SSRC必须设置为受保护的有效载荷流的SSRC。 FEC流与其对应流的关联是通过SDP[5]中的行分组与FEC语义[6]或其他外部方式完成的。
按照RFC 3550[1]第5.2节讨论的原则，FEC流及其相关的有效载荷流的复用通常由目的传输地址（网络地址和端口号）提供，每个RTP会话的目的传输地址是不同的。(1)对payload和FEC保护数据使用different网络路径或网络资源分配；(2)如果需要的话，接收媒体的子集，特别是对不理解FEC的主机；(3)接收器实现对不同媒体使用单独的进程。 此外，将FEC与有效载荷数据流复用会影响原始有效载荷流的时序和序列号空间，这通常是不可取的。 所以，FEC流和有效载荷流应该通过两个独立的RTPsession发送，而按有效载荷类型复用到一个单一的RTPsession中则应该避免。 此外，FEC和有效载荷MUSTNOT通过SSRC复用到一个单一的RTP会话中，因为它们总是具有相同的SSRC。
就像任何媒体流一样，FEC流的端口号和有效载荷类型号在SDP中的m行中传达，FEC没有静态的有效载荷类型分配，所以必须使用动态的payload类型号。 对号码的绑定由一个rtpmap属性来表示。 这个绑定中使用的名称是 "ulpfec"。 FEC流所在的地址在其对应的c行中传达。
FEC流与其保护的有效载荷流之间的关联关系是通过SDP(RFC 3388)[5]中的媒体线分组来传达的，使用的是FEC语义(RFC 4756)[6]。 FEC流和受保护的有效载荷流组成一个FEC组。
下面是一个多播会话中FEC应用的SDP示例。
v=0o=adam 289083124 289083124 IN IP4 host.example.coms=ULP FEC Seminart=0 0c=IN IP4 224.2.17. 12127a=group:FEC 1 2a=group:FEC 3 4m=audio 30000 RTPAVP 0a=mid:1m=application 30002 RTPAVP 100a=rtpmap:100 ulpfec8000a=mid:2m=video 30004 RTPAVP 31a=mid:3m=application 30004 RTPAVP 101c=IN IP4 224.2.17. 2.17.13127a=rtpmap:101 ulpfec8000a=mid:4这个SDP中出现两个a=组线，说明有两个FEC组。 第一个FEC组，如 "a=group:FEC 1 2 "行所示，由流1（使用PCM[14]的音频流）和流2（保护的FEC流）组成。 FEC流被发送到同一个组播组，并具有与音频相同的生存时间(TTL)，但端口号比音频高两个。 第二个FEC组，如 "a=group:FEC 3 4 "行所示，由流3（视频流）和流4（保护FEC流）组成。 FEC流被发送到不同的组播地址，但与有效载荷视频流的端口号相同（30004）。
14.2.  FEC作为冗余编码当FEC流以冗余编码格式作为辅助编解码器发送时，必须通过SDP发出信号。 为了做到这一点，RFC 2198[7]中定义的程序被用于信号冗余编码的使用。 FEC有效载荷类型的指示方式与任何其他二级编解码器相同。 FEC MUST只保护主编解码器，FEC引擎的有效载荷来自由主编解码器数据创建的虚拟RTP包。 虚拟RTP数据包可以很容易地从RFC 2198数据包中转换出来，方法很简单：(1)去掉所有的附加头和冗余编码数据，(2)用主编解码器的数据包替换RTP头中的有效载荷类型。
注：在RFC 2198规定的冗余编码的有效载荷格式中，一旦RED数据包中携带了主编码，标记位就会丢失。 所以无论是否使用FEC，标记位都不能恢复。
由于FEC数据（包括ULP头）与受保护的有效载荷在同一数据包中发送，因此FEC数据与受保护的有效载荷被捆绑在同一数据流中。
当FEC流以冗余编码格式作为辅助编解码器发送时，可以通过SDP发出信号。 要做到这一点，RFC 2198[7]中定义的程序被用于信号冗余编码的使用。 FEC有效载荷类型的指示方式与任何其他二级编解码器相同。 rtpmap属性必须用于指示FEC数据包的动态有效载荷类型号。FEC必须只保护主编解码器。
例如：
m=audio 12345 RTPAVP 121 0 5 100a=rtpmap:121 red80001a=rtpmap:100 ulpfec8000a=fmtp:121 05100这个SDP表示有一个单一的音频流，它可以包含PCM（媒体格式0）、DVI（媒体格式5）、冗余编码（由媒体格式121表示，它通过rtpmap属性绑定到red）或FEC（媒体格式100，它通过rtpmap属性绑定到ulpfec）。 虽然FECformat被指定为该流的一种可能的编码，但FECMUST NOT由其本身为该流发送。 它在mline中的存在是必需的，因为根据RFC 2198，非主要编解码器必须在这里列出。 fmtp属性表示可以使用冗余编码格式，DVI作为二级编码，FEC作为三级编码。
14.3.  要约答复的考虑当SDP用于要约答复[15]交换时，需要考虑一些问题。
onelevelonly "参数是声明性的。 对于声明为assendonly的流，该值表示是否只发送一个级别的FEC。 对于声明为recvonly或sendrecv的流，其值表示接收方接受的内容。
当FEC作为一个单独的流并通过SDP中的中线分组（RFC 3388）[5]使用FEC语义（RFC 4756）[6]进行信令发送时，提供方必须同时实现RFC 3388和RFC 4756.RFC 3388和RFC 4756中的提供应答规则SHALL befollowed with the following additional consideration.  对于所有带有FEC的提议，应答者可以通过将端口设置为0来拒绝单独的FEC会话，并删除 "a=group "属性，将该FEC会话与被保护的RTP会话进行分组。 如果应答者接受FEC的使用，则应答者只需在应答中包含相同的分组，就可以接受FEC RTPsession和offer中的分组。 请注意，拒绝FEC RTP会话并不妨碍媒体会话在没有FEC的情况下被接受和使用。
当FEC流作为二次编解码格式（RFC 2198）[7]发送时，提供方可以按照第14.2节的规定指示FEC流。 应答方可以通过删除FEC流的有效载荷类型来拒绝FEC流。 为了接受FEC的使用，应答方必须在应答中包括FEC的有效载荷类型。 注意，在使用冗余有效载荷格式[7]和FEC作为唯一的二级编解码器的情况下，当拒绝FEC流时，冗余编码有效载荷类型也应该被删除。
15.  应用说明本文档描述了一个前向纠错的通用协议，支持多种短块奇偶校验FEC算法，如简单和交错奇偶码。 该方案仅限于在48个数据包的距离上交错奇偶校验码。 这种FEC算法与不具备FEC能力的主机完全兼容。 由于媒体有效载荷不会被改变，而保护作为附加信息发送，所以不知道本文规定的通用FEC的接收者可以简单地忽略附加的FEC信息，并处理主媒体有效载荷。 这种互操作性对于与现有主机的兼容性特别重要，而且在许多不同主机需要同时相互通信的情况下，例如在多播期间。
本文件所述的通用FEC算法也是一种具有以下特点的通用保护算法。(1) 它与被保护媒体的性质无关，无论该媒体是音频、视频还是其他；(2) 它具有足够的灵活性，可以支持多种FEC机制和设置；(3) 它的设计具有自适应性，因此可以很容易地修改FEC参数，而无需借助于带外信令；(4) 它支持多种不同的FEC包传输机制。
这里指定的FEC还为用户提供了Unequal ErrorProtection功能。 一些其他算法也可以通过其他方式提供Unequal Error Protection功能。 Forexample，AVT工作组在 "An RTP Payload Format forErasure-Resilient Transmission of Progressive Multimedia Streams "中提出了一种Unequal Erasure Protection(UXP)方案，UXP方案通过将要保护的有效载荷流与使用Reed-Solomonoperations获得的附加冗余信息交织在一起，对媒体有效载荷进行不等效错误保护。
通过改变受保护媒体有效载荷的结构，UXPscheme牺牲了与不支持UXP的终端的向后兼容性。 这使得当需要向后兼容时，应用 UXP 更加困难。 然而，在ULP的情况下，媒体有效载荷保持不变，可以一直被终端使用。 如果接收终端不支持ULP，则可以直接忽略额外的保护。
同时，也因为在UXP中改变了媒体有效载荷的结构，UXP提供了改变数据包大小的独特能力，不受原始媒体有效载荷结构和所应用的保护的影响，只受协议开销的约束，这一特性在需要改变传输级媒体数据包大小的场景中非常有用。
由于UXP中使用了交织技术，在编码和解码两端都会有延迟。 对于UXP来说，在编码开始之前，一个传输块内的所有数据都需要到达，而且在一个传输块被解码之前，必须收到一定数量的数据包。 ULP方案在编码端引入的延迟很小。 在解码端，正确接收到的数据包可以立即传送。 只有当数据包丢失时，ULP才会引入延迟。
由于UXP是一种交错方案，在UXP保护的数据中发生的不可恢复的错误通常会导致有效载荷流中出现一些损坏的孔洞，而在ULP中，由于比特流中的数据包丢失而导致的不可恢复的错误通常会在数据包的末端出现连续的缺失。 另一方面，在 ULP 中，由于比特流中的数据包丢失而导致的不可恢复的错误通常会在数据包的末端出现连续的缺失片段，根据媒体有效载荷流的编码，许多应用程序可能会发现从一个末端只缺失一个连续片段的数据包中解析和提取数据比从一个有多个损坏孔的数据包中解析和提取数据更容易，特别是当这些孔与独立解码的片段边界不一致时。
ULP使用的独占或(XOR)奇偶校验操作比Reed-Solomon码所要求的复杂操作更简单、更快速。 这使得ULP更适合于计算成本受到限制的应用。
如上所述，ULP和UXP方案都对RTP媒体流应用了不等差保护，但各自使用的技术不同。 这两种方案都有自己独特的特点，可以应用于不同要求的场景。
16.  16. Acknowledgments以下作者对本文件作出了重大贡献。Adam H.Li、刘芳、John D.Villasenor、Dong-Seek Park、Jeong-Hoon Park、Yung-Lyul Lee、Jonathan D.Rosenberg和HenningSchulzrinne对本文件作出了重要贡献。 作者还要感谢许多人的建议，特别是Stephen Casner,JayFahlen,Cullen Jennings,Colin Perkins,Tao Tian,Matthieu Tisserand,Jeffery Tseng,Mark Watson,Stephen Wenger和Magnus Westerlund。
17.  参考文献17.1.  规范性参考文献[1] Schulzrinne，H.，Casner，S.，Frederick，R.，and V.Jacobson，"RTP：A Transport Protocol for Real-Time Applications"，STD 64，RFC 3550，July 2003.
[2] Bradner，S.，"Key words for use in RFCs to Indicate RequirementLevels"，BCP 14，RFC 2119，March 1997.
[3]Freed，N.和J.Klensin，"Media Type Specification andRegistration Procedures"，BCP 13，RFC 4288，2005年12月。