# Sender and Receiver Reports

`RTP` 接收端通过 `RTCP` 报告包的方式提供接收质量反馈的机制，报告包可以采取两种形式，取决于接收端是否也是发送端。 除了数据包类型代码外，发送者报告（`SR`）和接收者报告（`RR`）形式之间的唯一区别是发送者报告包括一个20字节的发送者信息，供处于激活状态的发送者使用。 如果一个站点在发布上一份报告或上一份报告后的时间间隔内发送了任何数据包，则发布 `SR`，否则发布 `RR`。

`SR` 和 `RR` 形式都包括0个或更多的接收报告块（`report blocks`），每个块都来自不同的同步源，即自上次报告以来，该接收端接收到 `RTP` 数据包的同步源。 对于 `CSRC` 列表中列出的贡献源，不会发布报告。 每个接收报告块都提供从该块的指定源接收的数据的统计信息。。 由于一个 `SR` 或 `RR` 数据包中最多可以容纳31个接收报告块，因此应根据需要在初始 `SR` 或 `RR` 数据包之后堆叠额外的 `RR` 数据包，以包含自上次报告以来的间隔期间所接收到的所有信源的接收报告。 如果有太多的信源，在不超过网络路径的 `MTU` 的情况下，一个复合 `RTCP` 包中无法容纳所有必要的 `RR` 包，那么每个间隔中只需要容纳一个 `MTU` 的子集。 子集应该在多个区间中循环选择，以便报告所有来源。

## 1. SR: Sender Report RTCP Packet

            0                   1                   2                   3
            0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
           +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    header |V=2|P|    RC   |   PT=SR=200   |             length            |
           +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
           |                         SSRC of sender                        |
           +=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+
    sender |              NTP timestamp, most significant word             |
    info   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
           |             NTP timestamp, least significant word             |
           +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
           |                         RTP timestamp                         |
           +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
           |                     sender's packet count                     |
           +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
           |                      sender's octet count                     |
           +=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+
    report |                 SSRC_1 (SSRC of first source)                 |
    block  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
      1    | fraction lost |       cumulative number of packets lost       |
           +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
           |           extended highest sequence number received           |
           +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
           |                      interarrival jitter                      |
           +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
           |                         last SR (LSR)                         |
           +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
           |                   delay since last SR (DLSR)                  |
           +=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+
    report |                 SSRC_2 (SSRC of second source)                |
    block  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
      2    :                               ...                             :
           +=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+
           |                  profile-specific extensions                  |
           +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

发件者报告包通常由三个部分组成，如果有定义的话，可能会包含第四个 `profile-specific` 扩展模块。 第一部分，即报头，占8个字节。 这些字段具有以下含义。

- version (V): 2bits

    版本信息，与 RTCP 包和 `RTP` 包中的版本信息相同，当前规格书中定义的版本号为2.

- padding (P): 1bit

    如果设置了 `padding` 位，这个单独的 `RTCP` 数据包在最后包含一些额外的填充字节，这些字节不是控制信息的一部分，但是包含在长度字段中。

- reception report count (RC): 5 bits

    该数据包中包含的接收报告块数，可为0.

- packet type (PT): 8 bits

    包含常数200，用于识别这是一个RTCP SR数据包。

- length: 16 bits

    这个 `RTCP` 包的长度，以32位字为单位减1，包括报头和任何填充物（偏移量为1使0成为有效的长度，并避免了在扫描复合RTCP包时可能出现的无限循环，而计数32位字则避免了在对4的倍数进行有效性检查时出错。)

- SSRC: 32 bits

    用于指定该 SR 包的同步源。

第二部，即发送者信息，包含20个字节，存在于每个发件者报告包中。 它总结了这个发件者的数据传输情况。 这些字段具有以下含义：

- NTP timestamp: 64 bits

    表示该报告发送时的挂钟时间（见第4节），以便与接收者的接收报告中返回的时间戳结合使用，测量到这些接收机的 `RTT` 情况。 接收者应有这样的预期，即时间戳的测量精度可能被限制在远低于 `NTP` 时间戳的分辨率下，且由于不知道，因此对时间戳的测量不确定性也不做指定。在一个没有挂钟时间概念，但有一些系统特定时钟（如 "系统正常运行时间"）的系统上，发送者可以使用该时钟作为参考来计算相对的 `NTP` 时间戳。 选择一个通用的时钟是很重要的，这样如果使用不同的实现来产生多媒体会话的各个流，所有的实现将使用相同的时钟。 直到2036年，相对时间戳和绝对时间戳在高位上会有所不同，所以如果进行比较就会显示出很大的差异；到那时，人们希望不再需要相对时间戳。 一个没有挂钟或经过时间（`elapsed time`) 概念的发送者可以将 `NTP` 时间戳设置为零。

- RTP timestamp: 32 bits

    对应于与 `NTP` 时间戳（如上）相同的时间，但与数据包中的 `RTP` 时间戳使用相同的单位和随机偏移。 这种对应关系使 `NTP` 时间戳可以被于同步源的媒体内和媒体间的同步，也可被不依赖媒体的接收者用来估计 `RTP` 标称时钟频率。 请注意，在大多数情况下，这个时间戳不等于任何相邻数据包中的 `RTP` 时间戳。 相反，它必须从相应的 `NTP` 时间戳计算出来，使用 `RTP` 时间戳计数器和实时之间的关系，通过定期检查采样瞬间的挂钟时间来维持。

- sender's packet count: 32 bits

    从开始传输到这个SR数据包生成之前，发送方传输的RTP数据包总数。 如果发送方改变其SSRC标识符，则应重新设置计数。

- sender's octet count: 32 bits

    发送方自开始传输到生成此 `SR` 数据包为止，在 `RTP` 数据包中传输的有效载荷字节数（即不包括头或填充）的总数。 如果发送方改变其SSRC标识符，该计数应该被重置。 该字段可用于估计平均有效载荷数据速率。

第三部分包含零个或多个接收报告块，取决于该发送方自上次报告以来所接收到的其他源的数量。 每个接收报告块都传达了从单个同步源接收 `RTP` 数据包的统计数据。 当一个源由于碰撞而改变其SSRC标识符时，接收者不应该将统计资料继承过来。 这些统计数据包括：

- SSRC_n (source identifier): 32 bits

    该接收报告块中信息所涉及的源的SSRC标识符。

- fraction lost: 8 bits

    从上一个 `SR` 或 `RR` 数据包发送后，从源 `SSRC_n` 丢失的 `RTP` 数据包的分数，用定点数表示，二进制点在字段的左边缘。 相当于将丢失分数乘以256后取整数部分）。 这个分数定义为丢失的数据包数除以预期的数据包数，定义在下一段。如果由于重复而导致丢包为负，则丢包的分数设为零。 注意，接收者无法判断在最后一个接收到的数据包之后是否有数据包丢失，如果在最后一个报告区间内从一个源发送的所有数据包都丢失了，那么将不会为该源发出接收报告块。

- cumulative number of packets lost: 24 bits

    从源 `SSRC_n` 开始接收后丢失的 `RTP` 数据包总数。 这个数字被定义为预期的数据包数量减去实际收到的数据包数量，其中收到的数据包数量包括任何延迟或重复的数据包。 因此，晚到的数据包不被计算为丢失，如果有重复的数据包，损失可能是负数。 预期的数据包数被定义为扩展最后收到的序列号(见下一字段的定义)，减去收到的初始序列号。

- extended highest sequence number received: 32 bits

    低16位包含从源 `SSRC_n` 接收到的 `RTP` 数据包中的最高序列号，高16位用相应的序列号循环数扩展了该序列号。 需要注意的是，同一会话内的不同接收机如果其启动时间相差较大，则会产生不同的序列号扩展。

- interarrival jitter: 32 bits

    `RTP` 数据包到达时间间隔的统计方差的估计值，以时间戳为单位，用无符号整数表示。 到达时间间隔抖动 `J` 被定义为一对数据包在接收方与发送方的数据包间距差异 `D` 的平均偏差（平滑的绝对值）。 如下式所示，这相当于两个数据包的 "相对传输时间" 之差；相对传输时间是指数据包的 `RTP` 时间戳与接收方在到达时的时钟之间的差值，测量单位相同。

    如果 `Si` 是来自数据包 `i` 的 `RTP` 时间戳，`Ri` 是数据包 `i` 的到达时间，以 `RTP` 时间戳为单位，那么对于两个数据包 `i` 和 `j`，`D` 可以表示为:

    D(i,j) = (Rj - Ri) - (Sj - Si) = (Rj - Sj) - (Ri - Si)

    当从源 `SSRC_n` 接收到每个数据包 `i` 时，应连续计算出到达间的抖动，根据公式，使用该数据包和前一个数据包 `i-1` 的到达顺序(不一定是顺序)的这个差值 `D` 。

    J(i) = J(i-1) + (|D(i-1,i)| - J(i-1))/ 16

    每当发出接收报告时，都会对 `J` 的当前值进行采样。

    抖动计算必须符合这里指定的公式，以便让与配置文件无关的监测器对来自不同实现的报告做出有效解释。 该算法是最佳的一阶估计器，增益参数1/16在保持合理的收敛速度的同时，也提供了良好的降噪比。参见后面关于改变数据包持续时间和传输前延迟的影响的讨论。

- last SR timestamp (LSR): 32 bits

    从源 `SSRC_n` 收到的最近的 `RTCP` 发送者报告（`SR`）的64位 `NTP` 时间戳中，取其中 32 位。 如果还没有收 到`SR`，则该字段设置为0。

- delay since last SR (DLSR): 32 bits

    从接收到源 `SSRC_n` 的最后一个 `SR` 包到发送这个接收报告块之间的延迟，单位为1/65536秒。 如果还没有收到来自 `SSRC_n` 的 `SR` 数据包，则 `DLSR` 字段设为0。

    用 `SSRC_r` 表示发出这个接收报告的接收方， 源 `SSRC_n` 可以通过记录收到这个接收报告块的时间 `A` 来计算到 `SSRC_r` 的往返传播时延。 它利用最后一个 `SR` 时间戳 (`LSR`) 字段计算出总的往返时间 `A-LSR`，然后减去这个字段，剩下的往返传播时延 = $A - LSR - DLSR$。 下图对此进行了说明。 时间以十六进制和等效的浮点十进制两种方式表示，共32位。 冒号表示一个32位字段分为16位整数部分和16位分数部分。

    这可以作为到集群接收器的距离的近似测量，尽管有些链路有非常不对称的延迟。
    ```
    [10 Nov 1995 11:33:25.125 UTC]       [10 Nov 1995 11:33:36.5 UTC]
    n                 SR(n)              A=b710:8000 (46864.500 s)
    ---------------------------------------------------------------->
                       v                 ^
    ntp_sec =0xb44db705 v               ^ dlsr=0x0005:4000 (    5.250s)
    ntp_frac=0x20000000  v             ^  lsr =0xb705:2000 (46853.125s)
      (3024992005.125 s)  v           ^
    r                      v         ^ RR(n)
    ---------------------------------------------------------------->
                           |<-DLSR->|
                            (5.250 s)
  
    A     0xb710:8000 (46864.500 s)
    DLSR -0x0005:4000 (    5.250 s)
    LSR  -0xb705:2000 (46853.125 s)
    -------------------------------
    delay 0x0006:2000 (    6.125 s)
  
            Figure 2: Example for round-trip time computation
    ``` 

## 2. RR: Receiver Report RTCP Packet

            0                   1                   2                   3
            0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
           +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    header |V=2|P|    RC   |   PT=RR=201   |             length            |
           +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
           |                     SSRC of packet sender                     |
           +=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+
    report |                 SSRC_1 (SSRC of first source)                 |
    block  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
      1    | fraction lost |       cumulative number of packets lost       |
           +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
           |           extended highest sequence number received           |
           +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
           |                      interarrival jitter                      |
           +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
           |                         last SR (LSR)                         |
           +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
           |                   delay since last SR (DLSR)                  |
           +=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+
    report |                 SSRC_2 (SSRC of second source)                |
    block  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
      2    :                               ...                             :
           +=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+
           |                  profile-specific extensions                  |
           +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

接收报告(`RR`)数据包的格式与`SR`数据包的格式相同，只是数据包类型字段为常数 `201`，并且省略了包含发送者信息的20个字节， 其余的字段与 `SR` 包的意义相同。

当没有数据传输或接收报告时，一个空的 `RR` 包(RC = 0)必须放在复合 `RTCP` 包的头部。

## 3. 扩展 Sender and Receiver Reports

如果需要定期报告发送者或接收者的额外信息，`profile-specific` 应该定义发送者报告和接收者报告的特定扩展。 这种方法应该优先于定义另一种 `RTCP` 数据包类型，因为它需要较少的开销：

1.  数据包中的字节数更少（没有 `RTCP` 头或 `SSRC` 字段）。

2. 更简单和更快的解析，因为在该 `profile-specific` 下运行的应用程序将被编程为，总是期望扩展字段就在接收报告后面的一个直接可获取的位置上。

扩展是发送者或接收者报告数据包中的第四部分，它在接收报告块（如果有的话）的最后。 如果需要额外的发送者信息，那么对于发送者报告，它将首先包含在扩展部分，但对于接收者报告，它将不存在。 如果要包括关于接收者的信息，那么该数据的结构应该是与现有的接收报告块数组平行的块数组；也就是说，块数将由RC字段表示。

## 4. 分析 Sender and Receiver Reports

这里的期望是，接收质量反馈不仅对发送方有用，而且对其他接收方和第三方监测方也有用。 发送方可以根据反馈修改其传输；接收方可以确定问题是局部的、区域的还是全局的；网络管理者可以使用与 `profile` 无关的监控器，通过只接收 `RTCP` 数据包而不接收相应的 `RTP` 数据包的方式, 来评估其网络的多播分发性能。

在发送者信息和接收者报告块中都使用了累积计数，因此可以计算任意两个报告之间的差异，以便在短期和长期内进行测量，并提供对丢包报告的弹性。 最近收到的两份报告之间的差异可以用来估计最近的分发质量。 包括 `NTP` 时间戳，以便可以从两个报告之间的差异计算速率。 由于该时间戳与数据编码的时钟速率无关，因此可以实现与编码和 `profile` 无关的质量监视器。

一个计算的例子是两个接收报告间隔内的丢包率。 累计丢失的数据包数的差值给出了该时间间隔内丢失的数量。 扩展的最后一个接收序列号的差值给出了该区间内预期的数据包数量。 这两者的比值就是该区间内的丢包分数。 如果两个报告是连续的，这个比值应该等于 `fraction lost` 字段，否则可能不等于。 每秒钟的丢包率可以通过将  丢包分数除以 `NTP` 时间戳的差值来获得，以秒为单位。 收到的数据包数是预期的数据包数减去丢失的数据包数。 预期的数据包数也可用于判断任何损失估计的统计有效性。 例如，5个数据包中丢失1个比1000个数据包中丢失200个的重要性要低。

从发送者信息中，第三方监控者可以在没有收到 `RTP` 数据的情况下，计算出平均有效载荷数据速率和一个区间内的平均数据包速率。 取两者的比值就可以得到平均有效载荷大小。 如果可以假设数据包丢失与数据包大小无关，那么某一个接收机收到的数据包数量乘以平均有效载荷大小(或相应的数据包大小)，就可以得到该接收机可用的表观吞吐量。

除了累计计数允许使用报告之间的差异进行长期的数据包丢失测量外，`fraction lost` 字段还提供了来自单个报告的短期测量。 当一个会话的规模扩大到足以使所有接收机的接收状态信息可能不会被保留，或者报告之间的间隔变得足够长，以至于可能只从一个特定的接收机收到一份报告时，这一点就变得更加重要。

到达时间间隔抖动字段提供了网络拥塞的第二个短期测量。 包丢失跟踪持续的拥塞，而抖动测量则跟踪短暂的拥塞。 抖动测量可以在导致丢包之前表明拥塞。 到达时间间隔抖动字段只是报告发送时网络抖动的快照，而不打算进行定量测量，相反，它的目的是为了比较来自一个接收方或来自多个接收方在一段时间内的报告，例如，在一个单一的网络内，同时进行比较。 为了比较不同的接收方，所有接收方的抖动必须按照相同的公式计算。

由于抖动计算是基于 `RTP` 时间戳，而 `RTP` 时间戳代表数据包中第一个数据被采样的瞬间，因此该采样瞬间和数据包被传输的时间之间的任何延迟变化都会影响计算出的抖动结果。 这样的延迟变化会发生在不同持续时间的音频数据包上。 对于视频编码也会出现这种情况，因为一帧的所有数据包的时间戳是相同的，但这些数据包并不是在同一时间传输的。 抖动计算作为对网络本身行为的衡量标准，传输前的延迟变化确实会降低其准确性，但考虑到接收方缓冲区必须容纳它，所以包括在内是合适的。 当抖动计算被用作比较测量时，由于传输前的延迟变化而导致的（恒定）分量被减去，这样就可以观察到网络抖动分量的变化，除非它的变化比较小。 如果变化较小，那么很可能是不重要的。